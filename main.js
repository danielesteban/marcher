!function(){"use strict";function e(){}function t(e){return e()}function n(){return Object.create(null)}function o(e){e.forEach(t)}function r(e){return"function"==typeof e}function i(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function s(t,...n){if(null==t)return e;const o=t.subscribe(...n);return o.unsubscribe?()=>o.unsubscribe():o}function a(e,t,n){e.$$.on_destroy.push(s(t,n))}function c(e,t,n,o){if(e){const r=l(e,t,n,o);return e[0](r)}}function l(e,t,n,o){return e[1]&&o?function(e,t){for(const n in t)e[n]=t[n];return e}(n.ctx.slice(),e[1](o(t))):n.ctx}function f(e,t,n,o){if(e[2]&&o){const r=e[2](o(n));if(void 0===t.dirty)return r;if("object"==typeof r){const e=[],n=Math.max(t.dirty.length,r.length);for(let o=0;o<n;o+=1)e[o]=t.dirty[o]|r[o];return e}return t.dirty|r}return t.dirty}function u(e,t,n,o,r,i){if(r){const s=l(t,n,o,i);e.p(s,r)}}function d(e){if(e.ctx.length>32){const t=[],n=e.ctx.length/32;for(let e=0;e<n;e++)t[e]=-1;return t}return-1}function p(e,t,n){return e.set(n),t}function h(e,t){e.appendChild(t)}function v(e,t,n){e.insertBefore(t,n||null)}function m(e){e.parentNode.removeChild(e)}function g(e,t){for(let n=0;n<e.length;n+=1)e[n]&&e[n].d(t)}function x(e){return document.createElement(e)}function b(e){return document.createTextNode(e)}function y(){return b(" ")}function w(){return b("")}function $(e,t,n,o){return e.addEventListener(t,n,o),()=>e.removeEventListener(t,n,o)}function S(e,t,n){null==n?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function F(e,t){t=""+t,e.wholeText!==t&&(e.data=t)}function M(e,t,n,o){null===n?e.style.removeProperty(t):e.style.setProperty(t,n,o?"important":"")}function z(e,t){for(let n=0;n<e.options.length;n+=1){const o=e.options[n];if(o.__value===t)return void(o.selected=!0)}e.selectedIndex=-1}function L(e,t,n){e.classList[n?"add":"remove"](t)}let k;function D(e){k=e}function P(e){(function(){if(!k)throw new Error("Function called outside component initialization");return k})().$$.on_mount.push(e)}const _=[],E=[],q=[],T=[],C=Promise.resolve();let B=!1;function R(){B||(B=!0,C.then(N))}function I(){return R(),C}function U(e){q.push(e)}const A=new Set;let G=0;function N(){const e=k;do{for(;G<_.length;){const e=_[G];G++,D(e),O(e.$$)}for(D(null),_.length=0,G=0;E.length;)E.pop()();for(let e=0;e<q.length;e+=1){const t=q[e];A.has(t)||(A.add(t),t())}q.length=0}while(_.length);for(;T.length;)T.pop()();B=!1,A.clear(),D(e)}function O(e){if(null!==e.fragment){e.update(),o(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(U)}}const j=new Set;let V;function W(){V={r:0,c:[],p:V}}function Y(){V.r||o(V.c),V=V.p}function X(e,t){e&&e.i&&(j.delete(e),e.i(t))}function H(e,t,n,o){if(e&&e.o){if(j.has(e))return;j.add(e),V.c.push((()=>{j.delete(e),o&&(n&&e.d(1),o())})),e.o(t)}else o&&o()}const K="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function J(e){e&&e.c()}function Z(e,n,i,s){const{fragment:a,on_mount:c,on_destroy:l,after_update:f}=e.$$;a&&a.m(n,i),s||U((()=>{const n=c.map(t).filter(r);l?l.push(...n):o(n),e.$$.on_mount=[]})),f.forEach(U)}function Q(e,t){const n=e.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function ee(t,r,i,s,a,c,l,f=[-1]){const u=k;D(t);const d=t.$$={fragment:null,ctx:null,props:c,update:e,not_equal:a,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(r.context||(u?u.$$.context:[])),callbacks:n(),dirty:f,skip_bound:!1,root:r.target||u.$$.root};l&&l(d.root);let p=!1;if(d.ctx=i?i(t,r.props||{},((e,n,...o)=>{const r=o.length?o[0]:n;return d.ctx&&a(d.ctx[e],d.ctx[e]=r)&&(!d.skip_bound&&d.bound[e]&&d.bound[e](r),p&&function(e,t){-1===e.$$.dirty[0]&&(_.push(e),R(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}(t,e)),n})):[],d.update(),p=!0,o(d.before_update),d.fragment=!!s&&s(d.ctx),r.target){if(r.hydrate){const e=function(e){return Array.from(e.childNodes)}(r.target);d.fragment&&d.fragment.l(e),e.forEach(m)}else d.fragment&&d.fragment.c();r.intro&&X(t.$$.fragment),Z(t,r.target,r.anchor,r.customElement),N()}D(u)}class te{$destroy(){Q(this,1),this.$destroy=e}$on(e,t){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const ne=[];function oe(t,n=e){let o;const r=new Set;function s(e){if(i(t,e)&&(t=e,o)){const e=!ne.length;for(const e of r)e[1](),ne.push(e,t);if(e){for(let e=0;e<ne.length;e+=2)ne[e][0](ne[e+1]);ne.length=0}}}return{set:s,update:function(e){s(e(t))},subscribe:function(i,a=e){const c=[i,a];return r.add(c),1===r.size&&(o=n(s)||e),i(t),()=>{r.delete(c),0===r.size&&(o(),o=null)}}}}const re=(e,t)=>{e=`marcher:${e}`;const n=localStorage.getItem(e),{subscribe:o,set:r}=oe(n?JSON.parse(n):t);return{subscribe:o,set:t=>{r(t),localStorage.setItem(e,JSON.stringify(t))}}},ie=["const background : vec3<f32> = vec3<f32>(0, 0, 0);\nconst fogDensity : f32 = 0.005;\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, background, 1 - exp(-fogDensity * fogDensity * depth * depth) * color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  return (\n    0.1\n    + getDirectLight(Light(position + vec3<f32>(0, 1, 0), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.5\n    + getDirectLight(Light(position + vec3<f32>(1, 1, 1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n    + getDirectLight(Light(position + vec3<f32>(-1, 1, -1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n  );\n}\n","const background : vec3<f32> = vec3<f32>(0, 0, 0);\nconst fogDensity : f32 = 0.005;\n\nconst edgeColor : vec3<f32> = vec3<f32>(0, 0, 0);\nconst edgeIntensity : f32 = 0.5;\nconst depthScale : f32 = 0.5;\nconst depthBias : f32 = 1;\nconst normalBias : f32 = 10;\nconst normalScale : f32 = 0.5;\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, edgeColor, getEdge(pixel, data) * edgeIntensity);\n  out = mix(out, background, 1 - exp(-fogDensity * fogDensity * depth * depth) * color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  return (\n    0.1\n    + getDirectLight(Light(position + vec3<f32>(0, 1, 0), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.5\n    + getDirectLight(Light(position + vec3<f32>(1, 1, 1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n    + getDirectLight(Light(position + vec3<f32>(-1, 1, -1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n  );\n}\n\nfn getEdge(pixel : vec2<i32>, data : vec4<f32>) -> f32 {\n  const offset : vec3<i32> = vec3<i32>(1, 1, 0);\n  let dataLeft : vec4<f32> = textureLoad(dataTexture, pixel - offset.xz, 0);\n  let dataRight : vec4<f32> = textureLoad(dataTexture, pixel + offset.xz, 0);\n  let dataUp : vec4<f32> = textureLoad(dataTexture, pixel + offset.zy, 0);\n  let dataDown : vec4<f32> = textureLoad(dataTexture, pixel - offset.zy, 0);\n  let edge : vec4<f32> = (\n    abs(dataLeft - data)\n    + abs(dataRight - data) \n    + abs(dataUp - data) \n    + abs(dataDown - data)\n  );\n  return clamp(max(pow((edge.x + edge.y + edge.z) * normalScale, normalBias), pow(edge.w * depthScale, depthBias)), 0, 1);\n}\n","const background : vec3<f32> = vec3<f32>(0, 0, 0);\nconst fogDensity : f32 = 0.005;\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, background, 1 - exp(-fogDensity * fogDensity * depth * depth) * color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  let light : Light = Light(\n    camera.position,\n    vec3<f32>(1, 1, 1),\n    vec3<f32>(0.3)\n  );\n  let theta = dot(camera.direction, -normalize(light.position - position));\n  return (\n    (\n      getDirectLight(light, normal, position, 128)\n      * getAttenuation(distance(light.position, position), 1, 0.007, 0.0002)\n      * clamp((theta - PI * 0.2) / (PI * 0.5), 0, 1)\n    )\n  );\n}\n","const background : vec3<f32> = vec3<f32>(0, 0, 0);\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, background, 1 - color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  const target : vec3<f32> = vec3<f32>(0, 0, -8);\n  let lights : array<Light, 2> = array<Light, 2>(\n    Light(\n      target + spherical(PI * 0.25, time, 8),\n      vec3<f32>(0.8, 0.4, 0),\n      vec3<f32>(0.3)\n    ),\n    Light(\n      target + spherical(PI * 0.25, time - PI, 8),\n      vec3<f32>(0, 0.2, 0.8),\n      vec3<f32>(0.3)\n    ),\n  );\n  var light : vec3<f32> = vec3<f32>(0.01);\n  for (var i : u32 = 0; i < 2; i++) {\n    light += (\n      getDirectLight(lights[i], normal, position, 32)\n      * getAttenuation(distance(lights[i].position, position), 1, 0.09, 0.032)\n    );\n  }\n  return light;\n}\n"],se={errors:oe([]),source:re("effect",ie[0])},ae=["fn getScene(pos : vec3<f32>) -> SDF {\n  let q : vec3<f32> = pos - vec3<f32>(0, 0, -8);\n  let d : f32 = sin(q.x * 10) * sin(q.y * 10) * sin(q.z * 10) * 0.1;\n  return SDF(\n    vec3<f32>(1, 1, 1) - vec3<f32>(d * 10, d * 5, d * 5),\n    sdSphere(q, 4) + d\n  );\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  let q : vec3<f32> = pos - vec3<f32>(0, 0, -8);\n  let d : f32 = sin(q.x * 10) * sin(q.y * 10) * sin(q.z * 10) * 0.1;\n\n  let a : SDF = SDF(\n    vec3<f32>(1, 1, 1) - vec3<f32>(d * 10, d * 5, d * 5),\n    sdSphere(q, 4) + d\n  );\n\n  let b : SDF = SDF(\n    clamp(vec3<f32>(0.5, 0.5, 0.5) + vec3<f32>(d * 10, d * 5, d * 5), vec3<f32>(0), vec3<f32>(1)),\n    sdSphere(q - vec3<f32>(0, 0, 4), 2) + d\n  );\n\n  return opSmoothSubstraction(a, b, 0.15);\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  var scene : SDF = SDF(\n    vec3<f32>(.8, .1, .05),\n    sdBox(rotateY(PI * 0.25) * rotateX(PI * 0.25) * (pos - vec3<f32>(-7, 0, -10)), vec3<f32>(1, 1, 1))\n  );\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.8, .2, .05),\n    sdCapsule(pos - vec3<f32>(-3.5, 0, -10), vec2<f32>(0.5, 2))\n  ));\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.2, .2, .8),\n    sdSphere(pos - vec3<f32>(0, 0, -10), 1)\n  ));\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.8, .2, .05),\n    sdEllipsoid(pos - vec3<f32>(3.5, 0, -10), vec3<f32>(1, 2, 1))\n  ));\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.8, .1, .05),\n    sdTorus(rotateX(PI * 0.5) * (pos - vec3<f32>(7, 0, -10)), vec2<f32>(1, 0.25))\n  ));\n  scene = opSmoothUnion(scene, SDF(\n    vec3<f32>(0.8, 0.8, 0.1),\n    sdPlane(pos, vec3<f32>(0, 1, 0), 1.5)\n  ), 1);\n  return scene;\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  const r : vec3<f32> = vec3<f32>(8, 8, 8);\n  let q = abs(pos % r) - r * 0.5;\n\n  let id : vec3<f32> = floor(pos / r);\n  let n = SimplexNoise(id);\n  let s = 1 + sin(id.x * id.y * id.z);\n  let di = 2 + (abs(id.x + id.y + id.z) % 8);\n  let d = sin(pos.x * di) * sin(pos.y * di) * sin(pos.z * di) * 0.1;\n\n  let a = SDF(\n    getColor(u32(abs(n + 0.5) * 0xFFFFFF)),\n    sdSphere(q + sin(id + time * 0.5) * (s * 0.5), s) + d\n  );\n  let b = SDF(\n    getColor(u32(abs(n - 0.5) * 0xFFFFFF)),\n    sdSphere(q - sin(id + time * sin(id.x + id.z) * 0.5) * (s * 0.5), s) - d\n  );\n  return opSmoothUnion(a, b, 1);\n}\n\nfn getColor(c : u32) -> vec3<f32> {\n  return vec3<f32>(\n    f32((c >> 16) & 0xFF) / 0xFF,\n    f32((c >> 8) & 0xFF) / 0xFF,\n    f32(c & 0xFF) / 0xFF,\n  );\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  let q = pos - vec3<f32>(0, 0, -64);\n  let n = abs(FBM(q * (0.06 + sin(time * 0.5) * 0.01) - 0.2));\n  return SDF(\n    hsl2Rgb(vec3<f32>(n, 0.7, 0.5)),\n    sdSphere(q, 32 - n * 8)\n  );\n}\n\nfn FBM(p : vec3<f32>) -> f32 {\n  var value : f32;\n  var amplitude : f32 = 0.5;\n  var q : vec3<f32> = p;\n  for (var i : i32 = 0; i < 3; i++) {\n    value += SimplexNoise(q) * amplitude;\n    q *= 2;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n"],ce={errors:oe([]),source:re("scene",ae[0])},le={gpu:null,input:null,iterations:re("iterations",300),mode:re("mode","raymarching")},fe=oe("scene");function ue(e,t,n){const o=e.slice();return o[11]=t[n].lineNum,o[12]=t[n].linePos,o[13]=t[n].type,o[14]=t[n].message,o[15]=t[n].line,o[16]=t[n].pointer,o}function de(e){let t,n,o,r,i,s,a,c,l,f,u,d,p,g,w,$,M,z=e[11]+"",L=e[12]+"",k=e[13]+"",D=e[14]+"",P=e[15]+"",_=e[16]+"";return{c(){t=x("div"),n=x("div"),o=b(":"),r=b(z),i=b(":"),s=b(L),a=y(),c=b(k),l=b(": "),f=b(D),u=y(),d=x("div"),p=b(P),g=y(),w=x("div"),$=b(_),M=y(),S(n,"class","svelte-1ozfs57"),S(d,"class","svelte-1ozfs57"),S(w,"class","svelte-1ozfs57"),S(t,"class","svelte-1ozfs57")},m(e,m){v(e,t,m),h(t,n),h(n,o),h(n,r),h(n,i),h(n,s),h(n,a),h(n,c),h(n,l),h(n,f),h(t,u),h(t,d),h(d,p),h(t,g),h(t,w),h(w,$),h(t,M)},p(e,t){4&t&&z!==(z=e[11]+"")&&F(r,z),4&t&&L!==(L=e[12]+"")&&F(s,L),4&t&&k!==(k=e[13]+"")&&F(c,k),4&t&&D!==(D=e[14]+"")&&F(f,D),4&t&&P!==(P=e[15]+"")&&F(p,P),4&t&&_!==(_=e[16]+"")&&F($,_)},d(e){e&&m(t)}}}function pe(t){let n,o,r,i,s,a,c,l,f,u,d,p,w,M,z=t[2].length+"",k=t[2],D=[];for(let e=0;e<k.length;e+=1)D[e]=de(ue(t,k,e));return{c(){n=x("div"),o=x("div"),r=y(),i=x("div"),s=x("div"),a=x("div"),c=y(),l=b(z),f=b(" errors\n      "),u=x("div"),d=y(),p=x("div");for(let e=0;e<D.length;e+=1)D[e].c();S(o,"class","wrapper svelte-1ozfs57"),S(a,"class","status svelte-1ozfs57"),L(a,"error",t[2].length),S(u,"class","arrow svelte-1ozfs57"),S(s,"class","toggle svelte-1ozfs57"),S(p,"class","messages svelte-1ozfs57"),S(i,"class","errors svelte-1ozfs57"),L(i,"open",t[1]),S(n,"class","editor svelte-1ozfs57")},m(e,m){v(e,n,m),h(n,o),t[7](o),h(n,r),h(n,i),h(i,s),h(s,a),h(s,c),h(s,l),h(s,f),h(s,u),h(i,d),h(i,p);for(let e=0;e<D.length;e+=1)D[e].m(p,null);w||(M=$(s,"click",t[5]),w=!0)},p(e,[t]){if(4&t&&L(a,"error",e[2].length),4&t&&z!==(z=e[2].length+"")&&F(l,z),4&t){let n;for(k=e[2],n=0;n<k.length;n+=1){const o=ue(e,k,n);D[n]?D[n].p(o,t):(D[n]=de(o),D[n].c(),D[n].m(p,null))}for(;n<D.length;n+=1)D[n].d(1);D.length=k.length}2&t&&L(i,"open",e[1])},i:e,o:e,d(e){e&&m(n),t[7](null),g(D,e),w=!1,M()}}}function he(e,t,n){let o,r,{state:i}=t;const{errors:s,source:c}=i;let l,f;a(e,s,(e=>n(2,r=e))),a(e,c,(e=>n(9,o=e)));let u=!1;const d=()=>f.layout();return P((()=>{let e,t=!0,r=!1;if(f=monaco.editor.create(l,{minimap:{enabled:!1},theme:"vs-dark"}),i.editor){const{model:e,view:t}=i.editor;f.setModel(e),f.restoreViewState(t)}else f.setModel(monaco.editor.createModel(o,"c"));const a=[s.subscribe((e=>{monaco.editor.setModelMarkers(f.getModel(),"Errors",e.map((({lineNum:e,linePos:t,length:n,message:o})=>({message:o,startLineNumber:e,endLineNumber:e,startColumn:t,endColumn:t+n}))))})),c.subscribe((e=>{t||(r=!0,f.setValue(e),r=!1)}))];return t=!1,f.onDidChangeModelContent((()=>{r||(e&&clearTimeout(e),e=setTimeout((()=>{t=!0,c.set(f.getValue()),t=!1}),300))})),f.focus(),window.addEventListener("resize",d,!1),()=>{n(6,i.editor={model:f.getModel(),view:f.saveViewState()},i),f.dispose(),clearTimeout(e),window.removeEventListener("resize",d),a.forEach((e=>e()))}})),e.$$set=e=>{"state"in e&&n(6,i=e.state)},[l,u,r,s,c,()=>{n(1,u=!u),I().then(d)},i,function(e){E[e?"unshift":"push"]((()=>{l=e,n(0,l)}))}]}class ve extends te{constructor(e){super(),ee(this,e,he,pe,i,{state:6})}}function me(t){let n,o;return n=new ve({props:{state:se}}),{c(){J(n.$$.fragment)},m(e,t){Z(n,e,t),o=!0},p:e,i(e){o||(X(n.$$.fragment,e),o=!0)},o(e){H(n.$$.fragment,e),o=!1},d(e){Q(n,e)}}}class ge extends te{constructor(e){super(),ee(this,e,null,me,i,{})}}function xe(t){let n,o;return n=new ve({props:{state:ce}}),{c(){J(n.$$.fragment)},m(e,t){Z(n,e,t),o=!0},p:e,i(e){o||(X(n.$$.fragment,e),o=!0)},o(e){H(n.$$.fragment,e),o=!1},d(e){Q(n,e)}}}class be extends te{constructor(e){super(),ee(this,e,null,xe,i,{})}}function ye(t){let n,o,r;return{c(){n=x("input"),S(n,"type","number"),S(n,"id",t[0]),S(n,"max",t[1]),S(n,"min",t[2]),S(n,"step",t[3]),n.value=t[5],S(n,"class","svelte-io5ur8")},m(e,i){v(e,n,i),o||(r=$(n,"input",t[6]),o=!0)},p(e,[t]){1&t&&S(n,"id",e[0]),2&t&&S(n,"max",e[1]),4&t&&S(n,"min",e[2]),8&t&&S(n,"step",e[3]),32&t&&n.value!==e[5]&&(n.value=e[5])},i:e,o:e,d(e){e&&m(n),o=!1,r()}}}function we(t,n,o){let r,i=e,a=()=>(i(),i=s(d,(e=>o(5,r=e))),d);t.$$.on_destroy.push((()=>i()));let{id:c}=n,{max:l}=n,{min:f}=n,{step:u}=n,{state:d}=n;a();return t.$$set=e=>{"id"in e&&o(0,c=e.id),"max"in e&&o(1,l=e.max),"min"in e&&o(2,f=e.min),"step"in e&&o(3,u=e.step),"state"in e&&a(o(4,d=e.state))},[c,l,f,u,d,r,({target:{value:e}})=>{p(d,r=parseInt(e,10),r)}]}class $e extends te{constructor(e){super(),ee(this,e,we,ye,i,{id:0,max:1,min:2,step:3,state:4})}}function Se(e,t,n){const o=e.slice();return o[2]=t[n].id,o[5]=t[n].name,o}function Fe(e){let t,n,o,r=e[5]+"";return{c(){t=x("option"),n=b(r),t.__value=o=e[2],t.value=t.__value},m(e,o){v(e,t,o),h(t,n)},p(e,i){1&i&&r!==(r=e[5]+"")&&F(n,r),1&i&&o!==(o=e[2])&&(t.__value=o,t.value=t.__value)},d(e){e&&m(t)}}}function Me(t){let n,o,r,i=t[0],s=[];for(let e=0;e<i.length;e+=1)s[e]=Fe(Se(t,i,e));return{c(){n=x("select");for(let e=0;e<s.length;e+=1)s[e].c();S(n,"id",t[2]),S(n,"class","svelte-146trro"),void 0===t[3]&&U((()=>t[4].call(n)))},m(e,i){v(e,n,i);for(let e=0;e<s.length;e+=1)s[e].m(n,null);z(n,t[3]),o||(r=$(n,"change",t[4]),o=!0)},p(e,[t]){if(1&t){let o;for(i=e[0],o=0;o<i.length;o+=1){const r=Se(e,i,o);s[o]?s[o].p(r,t):(s[o]=Fe(r),s[o].c(),s[o].m(n,null))}for(;o<s.length;o+=1)s[o].d(1);s.length=i.length}4&t&&S(n,"id",e[2]),9&t&&z(n,e[3])},i:e,o:e,d(e){e&&m(n),g(s,e),o=!1,r()}}}function ze(t,n,o){let r,i=e,a=()=>(i(),i=s(f,(e=>o(3,r=e))),f);t.$$.on_destroy.push((()=>i()));let{id:c}=n,{options:l}=n,{state:f}=n;return a(),t.$$set=e=>{"id"in e&&o(2,c=e.id),"options"in e&&o(0,l=e.options),"state"in e&&a(o(1,f=e.state))},[l,f,c,r,function(){r=function(e){const t=e.querySelector(":checked")||e.options[0];return t&&t.__value}(this),f.set(r),o(0,l)}]}class Le extends te{constructor(e){super(),ee(this,e,ze,Me,i,{id:2,options:0,state:1})}}function ke(e,t,n){const o=e.slice();return o[5]=t[n].id,o[6]=t[n].name,o}function De(e,t,n){const o=e.slice();return o[6]=t[n].name,o[9]=t[n].items,o}function Pe(e,t,n){const o=e.slice();return o[12]=t[n],o}function _e(t){let n,o,r=t[12]+"";return{c(){n=x("div"),o=b(r)},m(e,t){v(e,n,t),h(n,o)},p:e,d(e){e&&m(n)}}}function Ee(e){let t,n,o,r,i,s,a=e[6]+"",c=e[9],l=[];for(let t=0;t<c.length;t+=1)l[t]=_e(Pe(e,c,t));return{c(){t=x("div"),n=x("div"),o=b(a),r=y(),i=x("div");for(let e=0;e<l.length;e+=1)l[e].c();s=y(),S(n,"class","svelte-13z9b40"),S(i,"class","svelte-13z9b40"),S(t,"class","svelte-13z9b40")},m(e,a){v(e,t,a),h(t,n),h(n,o),h(t,r),h(t,i);for(let e=0;e<l.length;e+=1)l[e].m(i,null);h(t,s)},p(e,t){if(16&t){let n;for(c=e[9],n=0;n<c.length;n+=1){const o=Pe(e,c,n);l[n]?l[n].p(o,t):(l[n]=_e(o),l[n].c(),l[n].m(i,null))}for(;n<l.length;n+=1)l[n].d(1);l.length=c.length}},d(e){e&&m(t),g(l,e)}}}function qe(t){let n,o,r,i,s,a,c,l=t[5]+"",f=t[6]+"";return{c(){n=x("div"),o=x("div"),r=b(l),i=y(),s=x("div"),a=b(f),c=y(),S(o,"class","svelte-13z9b40"),S(s,"class","svelte-13z9b40"),S(n,"class","svelte-13z9b40")},m(e,t){v(e,n,t),h(n,o),h(o,r),h(n,i),h(n,s),h(s,a),h(n,c)},p:e,d(e){e&&m(n)}}}function Te(e){let t,n,o,r,i,s,a,c,l,f,u,d,p,b,w,$,F,M,z;i=new Le({props:{id:"mode",options:e[3],state:e[1]}}),f=new $e({props:{id:"iterations",state:e[0],step:100,min:100,max:1e3}});let L=e[4],k=[];for(let t=0;t<L.length;t+=1)k[t]=Ee(De(e,L,t));let D=e[2],P=[];for(let t=0;t<D.length;t+=1)P[t]=qe(ke(e,D,t));return{c(){t=x("div"),n=x("div"),o=x("label"),o.textContent="Mode:",r=y(),J(i.$$.fragment),s=y(),a=x("div"),c=x("label"),c.textContent="Max iterations:",l=y(),J(f.$$.fragment),u=y(),d=x("div"),d.textContent="Reference",p=y(),b=x("div");for(let e=0;e<k.length;e+=1)k[e].c();w=y(),$=x("div"),$.textContent="Controls",F=y(),M=x("div");for(let e=0;e<P.length;e+=1)P[e].c();S(o,"for","mode"),S(o,"class","svelte-13z9b40"),S(n,"class","input svelte-13z9b40"),S(c,"for","iterations"),S(c,"class","svelte-13z9b40"),S(a,"class","input svelte-13z9b40"),S(d,"class","heading svelte-13z9b40"),S(b,"class","reference svelte-13z9b40"),S($,"class","heading svelte-13z9b40"),S(M,"class","controls svelte-13z9b40"),S(t,"class","wrapper svelte-13z9b40")},m(e,m){v(e,t,m),h(t,n),h(n,o),h(n,r),Z(i,n,null),h(t,s),h(t,a),h(a,c),h(a,l),Z(f,a,null),h(t,u),h(t,d),h(t,p),h(t,b);for(let e=0;e<k.length;e+=1)k[e].m(b,null);h(t,w),h(t,$),h(t,F),h(t,M);for(let e=0;e<P.length;e+=1)P[e].m(M,null);z=!0},p(e,[t]){if(16&t){let n;for(L=e[4],n=0;n<L.length;n+=1){const o=De(e,L,n);k[n]?k[n].p(o,t):(k[n]=Ee(o),k[n].c(),k[n].m(b,null))}for(;n<k.length;n+=1)k[n].d(1);k.length=L.length}if(4&t){let n;for(D=e[2],n=0;n<D.length;n+=1){const o=ke(e,D,n);P[n]?P[n].p(o,t):(P[n]=qe(o),P[n].c(),P[n].m(M,null))}for(;n<P.length;n+=1)P[n].d(1);P.length=D.length}},i(e){z||(X(i.$$.fragment,e),X(f.$$.fragment,e),z=!0)},o(e){H(i.$$.fragment,e),H(f.$$.fragment,e),z=!1},d(e){e&&m(t),Q(i),Q(f),g(k,e),g(P,e)}}}function Ce(e){const{iterations:t,mode:n}=le;return[t,n,[{id:"W",name:"Move forwards"},{id:"A",name:"Move leftwards"},{id:"S",name:"Move backwards"},{id:"D",name:"Move rightwards"},{id:"Q",name:"Move downwards"},{id:"E",name:"Move upwards"},{id:"R",name:"Reset camera"},{id:"Shift",name:"Double movement speed"},{id:"Wheel",name:"Set movement speed"}],[{id:"raymarching",name:"Raymarching (better performance)"},{id:"conetracing",name:"Conetracing (better antialiasing)"}],[{name:"Color",items:["fn hsl2Rgb(hsl : vec3<f32>) -> vec3<f32>"]},{name:"Light",items:["struct Light { position : vec3<f32>, diffuse : vec3<f32>, specular : vec3<f32> }","fn getAttenuation(dist : f32, constant : f32, linear : f32, quadratic : f32) -> f32","fn getDirectLight(light : Light, normal : vec3<f32>, position : vec3<f32>, shininess : f32) -> vec3<f32>"]},{name:"Noise",items:["fn SimplexNoise(v : vec3<f32>) -> f32"]},{name:"Rotation",items:["const PI : f32","fn rotateX(radians : f32) -> mat3x3<f32>","fn rotateY(radians : f32) -> mat3x3<f32>","fn rotateZ(radians : f32) -> mat3x3<f32>","fn spherical(phi : f32, theta : f32, radius : f32) -> vec3<f32>"]},{name:"SDF",items:["struct SDF { color : vec3<f32>, distance : f32 }","fn opUnion(a : SDF, b : SDF) -> SDF","fn opSubstraction(a : SDF, b : SDF) -> SDF","fn opSmoothUnion(a : SDF, b : SDF, k : f32) -> SDF","fn opSmoothSubstraction(a : SDF, b : SDF, k : f32) -> SDF","fn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32","fn sdCapsule(p : vec3<f32>, r : vec2<f32>) -> f32","fn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32","fn sdPlane(p : vec3<f32>, n : vec3<f32>, h : f32) -> f32","fn sdSphere(p : vec3<f32>, r : f32) -> f32","fn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32"]},{name:"Uniforms",items:["struct Camera {","inverseMatrix : mat4x4<f32>,","position : vec3<f32>,","direction : vec3<f32>,","cone : f32,","near : f32,","far : f32,","}","var<uniform> camera : Camera;","var<uniform> time : f32;"]}]]}class Be extends te{constructor(e){super(),ee(this,e,Ce,Te,i,{})}}const Re=e=>({}),Ie=e=>({}),Ue=e=>({}),Ae=e=>({});function Ge(e){let t,n,o,r;const i=e[1].toggle,s=c(i,e,e[0],Ae),a=e[1].options,l=c(a,e,e[0],Ie);return{c(){t=x("div"),s&&s.c(),n=y(),o=x("div"),l&&l.c(),S(o,"class","options svelte-7xzgh1"),S(t,"class","dropdown svelte-7xzgh1")},m(e,i){v(e,t,i),s&&s.m(t,null),h(t,n),h(t,o),l&&l.m(o,null),r=!0},p(e,[t]){s&&s.p&&(!r||1&t)&&u(s,i,e,e[0],r?f(i,e[0],t,Ue):d(e[0]),Ae),l&&l.p&&(!r||1&t)&&u(l,a,e,e[0],r?f(a,e[0],t,Re):d(e[0]),Ie)},i(e){r||(X(s,e),X(l,e),r=!0)},o(e){H(s,e),H(l,e),r=!1},d(e){e&&m(t),s&&s.d(e),l&&l.d(e)}}}function Ne(e,t,n){let{$$slots:o={},$$scope:r}=t;return e.$$set=e=>{"$$scope"in e&&n(0,r=e.$$scope)},[r,o]}class Oe extends te{constructor(e){super(),ee(this,e,Ne,Ge,i,{})}}function je(e,t,n){const o=e.slice();return o[5]=t[n],o[7]=n,o}function Ve(e,t,n){const o=e.slice();return o[5]=t[n],o[7]=n,o}function We(e,t,n){const o=e.slice();return o[9]=t[n].id,o[10]=t[n].name,o}function Ye(e){let t,n,o,r,i,s=e[10]+"";return{c(){t=x("div"),n=b(s),o=y(),S(t,"class","view svelte-1uf5wr7"),L(t,"enabled",e[0]===e[9])},m(s,a){v(s,t,a),h(t,n),h(t,o),r||(i=$(t,"click",e[4](e[9])),r=!0)},p(n,o){e=n,3&o&&L(t,"enabled",e[0]===e[9])},d(e){e&&m(t),r=!1,i()}}}function Xe(e){let t,n;return t=new Oe({props:{$$slots:{options:[et],toggle:[He]},$$scope:{ctx:e}}}),{c(){J(t.$$.fragment)},m(e,o){Z(t,e,o),n=!0},p(e,n){const o={};8193&n&&(o.$$scope={dirty:n,ctx:e}),t.$set(o)},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){H(t.$$.fragment,e),n=!1},d(e){Q(t,e)}}}function He(t){let n;return{c(){n=x("div"),n.innerHTML='Examples\n          <div class="arrow svelte-1uf5wr7"></div>',S(n,"class","toggle svelte-1uf5wr7"),S(n,"slot","toggle")},m(e,t){v(e,n,t)},p:e,d(e){e&&m(n)}}}function Ke(e){let t,n=ie,o=[];for(let t=0;t<n.length;t+=1)o[t]=Ze(je(e,n,t));return{c(){for(let e=0;e<o.length;e+=1)o[e].c();t=w()},m(e,n){for(let t=0;t<o.length;t+=1)o[t].m(e,n);v(e,t,n)},p(e,r){if(4&r){let i;for(n=ie,i=0;i<n.length;i+=1){const s=je(e,n,i);o[i]?o[i].p(s,r):(o[i]=Ze(s),o[i].c(),o[i].m(t.parentNode,t))}for(;i<o.length;i+=1)o[i].d(1);o.length=n.length}},d(e){g(o,e),e&&m(t)}}}function Je(e){let t,n=ae,o=[];for(let t=0;t<n.length;t+=1)o[t]=Qe(Ve(e,n,t));return{c(){for(let e=0;e<o.length;e+=1)o[e].c();t=w()},m(e,n){for(let t=0;t<o.length;t+=1)o[t].m(e,n);v(e,t,n)},p(e,r){if(8&r){let i;for(n=ae,i=0;i<n.length;i+=1){const s=Ve(e,n,i);o[i]?o[i].p(s,r):(o[i]=Qe(s),o[i].c(),o[i].m(t.parentNode,t))}for(;i<o.length;i+=1)o[i].d(1);o.length=n.length}},d(e){g(o,e),e&&m(t)}}}function Ze(e){let t,n,o,r,i,s,a=e[7]+1+"";return{c(){t=x("div"),n=b("Effect "),o=b(a),r=y(),S(t,"class","action svelte-1uf5wr7")},m(a,c){v(a,t,c),h(t,n),h(t,o),h(t,r),i||(s=$(t,"click",e[2](e[5])),i=!0)},p(t,n){e=t},d(e){e&&m(t),i=!1,s()}}}function Qe(e){let t,n,o,r,i,s,a=e[7]+1+"";return{c(){t=x("div"),n=b("Scene "),o=b(a),r=y(),S(t,"class","action svelte-1uf5wr7")},m(a,c){v(a,t,c),h(t,n),h(t,o),h(t,r),i||(s=$(t,"click",e[3](e[5])),i=!0)},p(t,n){e=t},d(e){e&&m(t),i=!1,s()}}}function et(e){let t;function n(e,t){return"scene"===e[0]?Je:"effect"===e[0]?Ke:void 0}let o=n(e),r=o&&o(e);return{c(){r&&r.c(),t=w()},m(e,n){r&&r.m(e,n),v(e,t,n)},p(e,i){o===(o=n(e))&&r?r.p(e,i):(r&&r.d(1),r=o&&o(e),r&&(r.c(),r.m(t.parentNode,t)))},d(e){r&&r.d(e),e&&m(t)}}}function tt(e){let t,n,o,r,i,s=e[1],a=[];for(let t=0;t<s.length;t+=1)a[t]=Ye(We(e,s,t));let c="settings"!==e[0]&&Xe(e);return{c(){t=x("div"),n=x("div");for(let e=0;e<a.length;e+=1)a[e].c();o=y(),r=x("div"),c&&c.c(),S(n,"class","svelte-1uf5wr7"),S(r,"class","svelte-1uf5wr7"),S(t,"class","toolbar svelte-1uf5wr7")},m(e,s){v(e,t,s),h(t,n);for(let e=0;e<a.length;e+=1)a[e].m(n,null);h(t,o),h(t,r),c&&c.m(r,null),i=!0},p(e,[t]){if(19&t){let o;for(s=e[1],o=0;o<s.length;o+=1){const r=We(e,s,o);a[o]?a[o].p(r,t):(a[o]=Ye(r),a[o].c(),a[o].m(n,null))}for(;o<a.length;o+=1)a[o].d(1);a.length=s.length}"settings"!==e[0]?c?(c.p(e,t),1&t&&X(c,1)):(c=Xe(e),c.c(),X(c,1),c.m(r,null)):c&&(W(),H(c,1,1,(()=>{c=null})),Y())},i(e){i||(X(c),i=!0)},o(e){H(c),i=!1},d(e){e&&m(t),g(a,e),c&&c.d()}}}function nt(e,t,n){let o;a(e,fe,(e=>n(0,o=e)));return[o,[{id:"scene",name:"Scene"},{id:"effect",name:"Effect"},{id:"settings",name:"Settings"}],e=>()=>{delete se.editor,se.source.set(e)},e=>()=>{delete ce.editor,le.input.reset(),ce.source.set(e)},e=>()=>{p(fe,o=e,o)}]}class ot extends te{constructor(e){super(),ee(this,e,nt,tt,i,{})}}var rt=1e-6,it="undefined"!=typeof Float32Array?Float32Array:Array,st=Math.PI/180;function at(e){return e*st}function ct(){var e=new it(16);return it!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var lt=function(e,t,n,o,r){var i,s=1/Math.tan(t/2);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(i=1/(o-r),e[10]=(r+o)*i,e[14]=2*r*o*i):(e[10]=-1,e[14]=-2*o),e};function ft(){var e=new it(3);return it!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function ut(e,t,n){var o=new it(3);return o[0]=e,o[1]=t,o[2]=n,o}function dt(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function pt(e,t,n,o){return e[0]=t,e[1]=n,e[2]=o,e}function ht(e,t,n,o){return e[0]=t[0]+n[0]*o,e[1]=t[1]+n[1]*o,e[2]=t[2]+n[2]*o,e}function vt(e,t){var n=t[0],o=t[1],r=t[2],i=n*n+o*o+r*r;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}function mt(e){return e[0]=0,e[1]=0,e[2]=0,e}var gt=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function xt(){var e=new it(2);return it!=Float32Array&&(e[0]=0,e[1]=0),e}function bt(e,t){var n=new it(2);return n[0]=e,n[1]=t,n}function yt(e,t){return e[0]=t[0],e[1]=t[1],e}function wt(e,t,n){return e[0]=t,e[1]=n,e}ft(),function(){var e=xt()}();const $t=ut(0,1,0);class St{constructor({device:e,aspect:t=1,fov:n=75,near:o=.1,far:r=1e4}){this.device=e,this.data=new Float32Array(26),this.buffer=e.createBuffer({size:this.data.byteLength+Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=t,this.fov=n,this.near=o,this.far=r,this.inverseMatrix=this.data.subarray(0,16),this.position=this.data.subarray(16,19),this.direction=this.data.subarray(20,23),this.cone=this.data.subarray(23,24),this.data[24]=o,this.data[25]=r,this.projectionMatrix=ct(),this.viewMatrix=ct(),this.target=ft()}setSize(e,t){const{fov:n}=this;this.aspect=e/t,this.cone[0]=2*Math.tan(at(n)/2)/t,this.updateProjection()}updateProjection(){const{projectionMatrix:e,aspect:t,fov:n,near:o,far:r}=this;lt(e,at(n),t,o,r),this.updateBuffer()}updateView(){const{viewMatrix:e,direction:t,position:n,target:o}=this;var r,i,s,a,c,l,f,u,d,p,h,v,m,g,x,b,y,w,$,S,F,M,z;vt(t,gt(t,o,n)),r=e,s=o,a=$t,x=(i=n)[0],b=i[1],y=i[2],w=a[0],$=a[1],S=a[2],F=s[0],M=s[1],z=s[2],Math.abs(x-F)<rt&&Math.abs(b-M)<rt&&Math.abs(y-z)<rt?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(r):(h=x-F,v=b-M,m=y-z,c=$*(m*=g=1/Math.hypot(h,v,m))-S*(v*=g),l=S*(h*=g)-w*m,f=w*v-$*h,(g=Math.hypot(c,l,f))?(c*=g=1/g,l*=g,f*=g):(c=0,l=0,f=0),u=v*f-m*l,d=m*c-h*f,p=h*l-v*c,(g=Math.hypot(u,d,p))?(u*=g=1/g,d*=g,p*=g):(u=0,d=0,p=0),r[0]=c,r[1]=u,r[2]=h,r[3]=0,r[4]=l,r[5]=d,r[6]=v,r[7]=0,r[8]=f,r[9]=p,r[10]=m,r[11]=0,r[12]=-(c*x+l*b+f*y),r[13]=-(u*x+d*b+p*y),r[14]=-(h*x+v*b+m*y),r[15]=1),this.updateBuffer()}updateBuffer(){const{buffer:e,data:t,device:n,projectionMatrix:o,viewMatrix:r,inverseMatrix:i}=this;var s,a,c,l,f,u,d,p,h,v,m,g,x,b,y,w,$,S,F,M,z,L,k;!function(e,t){var n=t[0],o=t[1],r=t[2],i=t[3],s=t[4],a=t[5],c=t[6],l=t[7],f=t[8],u=t[9],d=t[10],p=t[11],h=t[12],v=t[13],m=t[14],g=t[15],x=n*a-o*s,b=n*c-r*s,y=n*l-i*s,w=o*c-r*a,$=o*l-i*a,S=r*l-i*c,F=f*v-u*h,M=f*m-d*h,z=f*g-p*h,L=u*m-d*v,k=u*g-p*v,D=d*g-p*m,P=x*D-b*k+y*L+w*z-$*M+S*F;P&&(P=1/P,e[0]=(a*D-c*k+l*L)*P,e[1]=(r*k-o*D-i*L)*P,e[2]=(v*S-m*$+g*w)*P,e[3]=(d*$-u*S-p*w)*P,e[4]=(c*z-s*D-l*M)*P,e[5]=(n*D-r*z+i*M)*P,e[6]=(m*y-h*S-g*b)*P,e[7]=(f*S-d*y+p*b)*P,e[8]=(s*k-a*z+l*F)*P,e[9]=(o*z-n*k-i*F)*P,e[10]=(h*$-v*y+g*x)*P,e[11]=(u*y-f*$-p*x)*P,e[12]=(a*M-s*L-c*F)*P,e[13]=(n*L-o*M+r*F)*P,e[14]=(v*b-h*w-m*x)*P,e[15]=(f*w-u*b+d*x)*P)}(i,(s=i,a=o,c=r,l=a[0],f=a[1],u=a[2],d=a[3],p=a[4],h=a[5],v=a[6],m=a[7],g=a[8],x=a[9],b=a[10],y=a[11],w=a[12],$=a[13],S=a[14],F=a[15],M=c[0],z=c[1],L=c[2],k=c[3],s[0]=M*l+z*p+L*g+k*w,s[1]=M*f+z*h+L*x+k*$,s[2]=M*u+z*v+L*b+k*S,s[3]=M*d+z*m+L*y+k*F,M=c[4],z=c[5],L=c[6],k=c[7],s[4]=M*l+z*p+L*g+k*w,s[5]=M*f+z*h+L*x+k*$,s[6]=M*u+z*v+L*b+k*S,s[7]=M*d+z*m+L*y+k*F,M=c[8],z=c[9],L=c[10],k=c[11],s[8]=M*l+z*p+L*g+k*w,s[9]=M*f+z*h+L*x+k*$,s[10]=M*u+z*v+L*b+k*S,s[11]=M*d+z*m+L*y+k*F,M=c[12],z=c[13],L=c[14],k=c[15],s[12]=M*l+z*p+L*g+k*w,s[13]=M*f+z*h+L*x+k*$,s[14]=M*u+z*v+L*b+k*S,s[15]=M*d+z*m+L*y+k*F,s)),n.queue.writeBuffer(e,0,t)}}St.WGSL="\nstruct Camera {\n  inverseMatrix : mat4x4<f32>,\n  position : vec3<f32>,\n  direction : vec3<f32>,\n  cone : f32,\n  near : f32,\n  far : f32,\n}\n";const Ft=ft(),Mt=xt(),zt=ft(),Lt=ft(),kt=ft(),Dt=ut(0,1,0);class Pt{constructor({camera:e,target:t}){var n,o;this.camera=e,this.target=t,this.isFullscreen=!1,this.isLocked=!1,this.gamepad=null,this.keyboard={buttons:{run:!1},movement:ft()},this.pointer={buttons:{primary:!1},movement:xt(),position:xt()},this.buttons={primary:!1},this.forward=ft(),this.look={state:bt(.5*Math.PI,Math.PI),target:bt(.5*Math.PI,Math.PI)},this.position={state:e.position,target:(n=e.position,o=new it(3),o[0]=n[0],o[1]=n[1],o[2]=n[2],o)},this.speed={state:4,target:4},this.updateBounds(),t.addEventListener("contextmenu",this.onContextMenu.bind(this),!1),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnected.bind(this),!1),window.addEventListener("gamepadconnected",this.onGamepadConnected.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1),t.addEventListener("mousedown",this.onMouseDown.bind(this),!1),window.addEventListener("mousemove",this.onMouseMove.bind(this),!1),window.addEventListener("mouseup",this.onMouseUp.bind(this),!1),window.addEventListener("wheel",this.onMouseWheel.bind(this),{passive:!1}),document.addEventListener("fullscreenchange",this.onFullscreen.bind(this),!1),document.addEventListener("pointerlockchange",this.onPointerLock.bind(this),!1)}enterFullscreen(){const{isFullscreen:e,target:t}=this;e||t.requestFullscreen()}exitFullscreen(){const{isFullscreen:e}=this;e&&document.exitFullscreen()}lock(){const{isLocked:e,target:t}=this;e||t.requestPointerLock()}unlock(){const{isLocked:e}=this;e&&document.exitPointerLock()}onContextMenu(e){e.preventDefault()}onGamepadDisconnected({gamepad:{index:e}}){const{gamepad:t}=this;t===e&&(this.gamepad=null)}onGamepadConnected({gamepad:{index:e}}){this.gamepad=e}onKeyDown({key:e,repeat:t}){const{isLocked:n,keyboard:o}=this;if(n&&!t)switch(e.toLowerCase()){case"w":o.movement[2]=1;break;case"s":o.movement[2]=-1;break;case"a":o.movement[0]=-1;break;case"d":o.movement[0]=1;break;case"q":o.movement[1]=-1;break;case"e":o.movement[1]=1;break;case"shift":o.buttons.run=!0;break;case"r":this.reset()}}onKeyUp({key:e}){const{isLocked:t,keyboard:n}=this;if(t)switch(e.toLowerCase()){case"w":n.movement[2]>0&&(n.movement[2]=0);break;case"s":n.movement[2]<0&&(n.movement[2]=0);break;case"a":n.movement[0]<0&&(n.movement[0]=0);break;case"d":n.movement[0]>0&&(n.movement[0]=0);break;case"q":n.movement[1]<0&&(n.movement[1]=0);break;case"e":n.movement[1]>0&&(n.movement[1]=0);break;case"shift":n.buttons.run=!1}}onMouseDown({button:e}){const{isFullscreen:t,isLocked:n,pointer:o}=this;if(!n)return this.lock(),void(t||this.enterFullscreen());o.buttons.primary=0===e||2===e}onMouseMove({clientX:e,clientY:t,movementX:n,movementY:o}){const{sensitivity:r}=Pt,{bounds:i,isLocked:s,pointer:{movement:a,position:c}}=this;s&&(a[0]-=n*r.pointer,a[1]+=o*r.pointer,wt(c,(e-i.x)/i.width*2-1,-(t-i.y)/i.height*2+1))}onMouseUp({button:e}){const{isLocked:t,pointer:n}=this;!t||0!==e&&2!==e||(n.buttons.primary=!1)}onMouseWheel(e){const{sensitivity:t,minSpeed:n,speedRange:o}=Pt,{isLocked:r,speed:i}=this;if(e.ctrlKey&&e.preventDefault(),!r)return;const s=Math.min(Math.max((Math.log(i.target)-n)/o-e.deltaY*t.wheel,0),1);i.target=Math.exp(n+s*o)}onFullscreen(){this.isFullscreen=!!document.fullscreenElement}onPointerLock(){const{buttons:e,keyboard:t,pointer:n}=this;this.isLocked=!!document.pointerLockElement,this.isLocked||(e.primary=!1,pt(t.movement,0,0,0),t.buttons.run=!1,n.buttons.primary=!1)}update(e){const{minPhi:t,maxPhi:n,sensitivity:o}=Pt,{isLocked:r,buttons:i,camera:s,forward:a,gamepad:c,keyboard:l,pointer:f,look:u,position:d,speed:p}=this;let h=!1;if(r){if(h=l.buttons.run,i.primary=f.buttons.primary,dt(zt,l.movement),yt(Mt,f.movement),null!==c){const{axes:e,buttons:t}=navigator.getGamepads()[c];(t[6]&&t[6].pressed||t[7]&&t[7].pressed)&&(i.primary=!0),Math.max(Math.abs(e[2]),Math.abs(e[3]))>.1&&wt(Mt,-e[2]*o.gamepad,-e[3]*o.gamepad),Math.max(Math.abs(e[0]),Math.abs(e[1]))>.1&&pt(zt,e[0],0,-e[1]),t[4]&&t[4].pressed?zt[1]=-1:t[5]&&t[5].pressed&&(zt[1]=1),t[10]&&t[10].pressed&&(h=!0)}u.target[0]=Math.min(Math.max(u.target[0]+Mt[1],t),n),u.target[1]+=Mt[0]}wt(f.movement,0,0);{const t=1-Math.exp(-20*e);v=u.state,m=u.state,g=u.target,x=t,b=m[0],y=m[1],v[0]=b+x*(g[0]-b),v[1]=y+x*(g[1]-y),p.state=p.state*(1-t)+p.target*t}var v,m,g,x,b,y;if(pt(a,Math.sin(u.state[0])*Math.sin(u.state[1]),Math.cos(u.state[0]),Math.sin(u.state[0])*Math.cos(u.state[1])),0!==zt[0]||0!==zt[1]||0!==zt[2]){dt(Lt,a),vt(kt,function(e,t,n){var o=t[0],r=t[1],i=t[2],s=n[0],a=n[1],c=n[2];return e[0]=r*c-i*a,e[1]=i*s-o*c,e[2]=o*a-r*s,e}(kt,Lt,Dt)),mt(Ft),ht(Ft,Ft,kt,zt[0]),ht(Ft,Ft,Dt,zt[1]),ht(Ft,Ft,Lt,zt[2]),mt(zt);const t=function(e){var t=e[0],n=e[1],o=e[2];return Math.hypot(t,n,o)}(Ft);t>1&&function(e,t,n){e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n}(Ft,Ft,1/t),ht(d.target,d.target,Ft,e*p.state*(h?2:1))}{const t=1-Math.exp(-10*e);!function(e,t,n,o){var r=t[0],i=t[1],s=t[2];e[0]=r+o*(n[0]-r),e[1]=i+o*(n[1]-i),e[2]=s+o*(n[2]-s)}(d.state,d.state,d.target,t),function(e,t,n){e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2]}(s.target,s.position,a),s.updateView()}}updateBounds(){const{target:e}=this,t=e.getBoundingClientRect();this.bounds={width:Math.max(t.width,1),height:Math.max(t.height,1),x:t.x,y:t.y}}reset(){const{look:e,position:t}=this;mt(t.target),dt(t.state,t.target),wt(e.target,.5*Math.PI,Math.PI),yt(e.state,e.target)}}Pt.sensitivity={gamepad:.03,pointer:.003,wheel:3e-4},Pt.minPhi=.01,Pt.maxPhi=Math.PI-.01,Pt.minSpeed=Math.log(2),Pt.maxSpeed=Math.log(64),Pt.speedRange=Pt.maxSpeed-Pt.minSpeed;var _t="struct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) ray : vec3<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> time : f32;\n\nconst epsilon : f32 = 0.01;\n\nfn getNormal(pos : vec3<f32>, distance : f32) -> vec3<f32> {\n  const o : vec2<f32> = vec2<f32>(epsilon, 0);\n  return normalize(\n    distance - vec3<f32>(\n      getScene(pos - o.xyy).distance,\n      getScene(pos - o.yxy).distance,\n      getScene(pos - o.yyx).distance\n    )\n  );\n}\n\n@vertex\nfn vertex(@builtin(vertex_index) index : u32) -> VertexOutput {\n  // Hack to prevent BindGroup errors\n  // when user code doesn't use all of the uniforms\n  let t : f32 = time;\n\n  const quad = array<vec2<f32>, 6>(\n    vec2<f32>(-1, -1), vec2<f32>(1, -1), vec2<f32>(-1, 1),\n    vec2<f32>(-1, 1), vec2<f32>(1, -1), vec2<f32>(1, 1)\n  );\n  var out : VertexOutput;\n  out.position = vec4<f32>(quad[index], 0, 1);\n  let r : vec4<f32> = camera.inverseMatrix * vec4<f32>(quad[index], 0.5, 1);\n  out.ray = normalize((r.xyz / r.w) - camera.position);\n  return out;\n}\n\n@fragment\nfn conetracing(@location(0) ray : vec3<f32>) -> FragmentOutput {\n  var out : FragmentOutput;\n  var coverage : f32 = 1;\n  var depth : f32 = camera.near;\n  for (var i : u32 = 0; i < maxIterations && depth < camera.far; i++) {\n    let pos : vec3<f32> = camera.position + ray * depth;\n    let step : SDF = getScene(pos);\n    let cone : f32 = camera.cone * depth;\n    if (step.distance < cone) {\n      let alpha : f32 = smoothstep(cone, -cone, step.distance);\n      let normal : vec3<f32> = getNormal(pos, step.distance);\n      out.color += vec4<f32>(step.color * alpha * coverage, 0);\n      out.data += vec4<f32>(normal, depth) * alpha * coverage;\n      out.position += vec4<f32>(pos * alpha * coverage, 0);\n      coverage *= 1 - alpha;\n      if (coverage <= epsilon * 0.1) {\n        break;\n      }\n    }\n    depth += max(step.distance, epsilon);\n  }\n  if (coverage < 1) {\n    out.color = vec4<f32>(out.color.xyz, 1 - coverage);\n    out.data = vec4<f32>(normalize(out.data.xyz), out.data.w);\n    return out;\n  }\n  discard;\n}\n\n@fragment\nfn raymarching(@location(0) ray : vec3<f32>) -> FragmentOutput {\n  var out : FragmentOutput;\n  var depth : f32 = camera.near;\n  for (var i : u32 = 0; i < maxIterations && depth < camera.far; i++) {\n    let pos : vec3<f32> = camera.position + ray * depth;\n    let step : SDF = getScene(pos);\n    if (step.distance < epsilon) {\n      let normal : vec3<f32> = getNormal(pos, step.distance);\n      out.color = vec4<f32>(step.color, 1);\n      out.data = vec4<f32>(normal, depth);\n      out.position = vec4<f32>(pos, 1);\n      return out;\n    }\n    depth += max(step.distance, epsilon);\n  }\n  discard;\n}\n",Et="fn hsl2Rgb(hsl : vec3<f32>) -> vec3<f32> {\n  let h : f32 = clamp(hsl.x, 0, 1);\n  let s : f32 = clamp(hsl.y, 0, 1);\n  let l : f32 = clamp(hsl.z, 0, 1);\n  if (s == 0) {\n    return vec3<f32>(l, l, l);\n  }\n  var q : f32;\n  if (l < 0.5) {\n    q = l * (1 + s);\n  } else {\n    q = l + s - l * s;\n  }\n  let p = 2 * l - q;\n  return vec3<f32>(\n    hue2Rgb(p, q, h + 1 / 3.0),\n    hue2Rgb(p, q, h),\n    hue2Rgb(p, q, h - 1 / 3.0)\n  );\n}\n\nfn hue2Rgb(p : f32, q : f32, tt : f32) -> f32 {\n  var t : f32 = tt;\n  if (t < 0) { t += 1; }\n  if (t > 1) { t -= 1; }\n  if (t < 1 / 6.0) { return p + (q - p) * 6 * t; }\n  if (t < 1 / 2.0) { return q; }\n  if (t < 2 / 3.0) { return p + (q - p) * (2 / 3.0 - t) * 6; }\n  return p;\n}\n",qt="fn permute4(x : vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r : vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn SimplexNoise(v : vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n",Tt="const PI : f32 = 3.141592653589793;\n\nfn rotateX(radians : f32) -> mat3x3<f32> {\n  var c : f32 = cos(radians);\n  var s : f32 = sin(radians);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(radians : f32) -> mat3x3<f32> {\n  var c : f32 = cos(radians);\n  var s : f32 = sin(radians);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn rotateZ(radians : f32) -> mat3x3<f32> {\n  var c : f32 = cos(radians);\n  var s : f32 = sin(radians);\n  return mat3x3<f32>(\n    c, s, 0,\n    -s, c, 0,\n    0, 0, 1,\n  );\n}\n\nfn spherical(phi : f32, theta : f32, radius : f32) -> vec3<f32> {\n  let sinPhiRadius = sin(phi) * radius;\n  return vec3<f32>(\n    sinPhiRadius * sin(theta),\n    cos(phi) * radius,\n    sinPhiRadius * cos(theta)\n  );\n}\n",Ct="struct SDF {\n  color : vec3<f32>,\n  distance : f32,\n}\n\nfn opUnion(a : SDF, b : SDF) -> SDF {\n  if (a.distance < b.distance) {\n    return a;\n  }\n  return b;\n}\n\nfn opSubstraction(a : SDF, b : SDF) -> SDF {\n  if (a.distance > -b.distance) {\n    return a;\n  }\n  return SDF(b.color, -b.distance);\n}\n\nfn opSmoothUnion(a : SDF, b : SDF, k : f32) -> SDF {\n  let h : f32 = clamp(0.5 + 0.5 * (b.distance - a.distance) / k, 0, 1);\n  return SDF(\n    mix(b.color, a.color, h),\n    mix(b.distance, a.distance, h) - k*h*(1-h)\n  );\n}\n\nfn opSmoothSubstraction(a : SDF, b : SDF, k : f32) -> SDF {\n  let h : f32 = clamp(0.5 - 0.5 * (a.distance + b.distance) / k, 0, 1);\n  return SDF(\n    mix(a.color, b.color, h),\n    mix(a.distance, -b.distance, h) + k*h*(1-h)\n  );\n}\n\nfn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  let q : vec3<f32> = abs(p) - r;\n  return length(max(q, vec3<f32>(0))) + min(max(q.x, max(q.y, q.z)), 0);\n}\n\nfn sdCapsule(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  let q : vec3<f32> = vec3<f32>(p.x, p.y - clamp(p.y, -r.y + r.x, r.y - r.x), p.z);\n  return length(q) - r.x;\n}\n\nfn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  let k0 : f32 = length(p / r);\n  let k1 : f32 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfn sdPlane(p : vec3<f32>, n : vec3<f32>, h : f32) -> f32 {\n  return dot(p,n) + h;\n}\n\nfn sdSphere(p : vec3<f32>, r : f32) -> f32 {\n  return length(p) - r;\n}\n\nfn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  let q : vec2<f32> = vec2<f32>(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n";class Bt{constructor(e){this.renderer=e}render(e){const{bindings:t,pipeline:n}=this;e.setPipeline(n),e.setBindGroup(0,t),e.draw(6)}setMaxIterations(e){this.maxIterations=e,this.updatePipeline()}setMode(e){this.mode=e,this.updatePipeline()}setScene(e){this.scene=e,this.updatePipeline()}updatePipeline(){const{renderer:{camera:e,device:t,time:n},maxIterations:o,mode:r,scene:i}=this;o&&r&&i&&(this.code=[`const maxIterations : u32 = ${o};`,e.constructor.WGSL,_t,Et,qt,Tt,Ct,"// __SOURCE__",i].join("\n"),this.module=t.createShaderModule({code:this.code}),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{entryPoint:"vertex",module:this.module},fragment:{entryPoint:r,module:this.module,targets:[{format:"rgba32float"},{format:"rgba32float"},{format:"rgba32float"}]},primitive:{topology:"triangle-list"}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:{buffer:n}}]}))}}var Rt="@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> time : f32;\n@group(1) @binding(0) var colorTexture : texture_2d<f32>;\n@group(1) @binding(1) var dataTexture : texture_2d<f32>;\n@group(1) @binding(2) var positionTexture : texture_2d<f32>;\n\nfn linearTosRGB(linear : vec3<f32>) -> vec3<f32> {\n  if (all(linear <= vec3<f32>(0.0031308))) {\n    return linear * 12.92;\n  }\n  return (pow(abs(linear), vec3<f32>(1.0/2.4)) * 1.055) - vec3<f32>(0.055);\n}\n\n@vertex\nfn vertex(@builtin(vertex_index) index : u32) -> @builtin(position) vec4<f32> {\n  // Hack to prevent BindGroup errors\n  // when user code doesn't use all of the uniforms\n  let t : f32 = time;\n\n  const quad = array<vec2<f32>, 6>(\n    vec2<f32>(-1, -1), vec2<f32>(1, -1), vec2<f32>(-1, 1),\n    vec2<f32>(-1, 1), vec2<f32>(1, -1), vec2<f32>(1, 1)\n  );\n  return vec4<f32>(quad[index], 0, 1);\n}\n\n@fragment\nfn fragment(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  return vec4<f32>(linearTosRGB(getEffect(vec2<i32>(floor(uv.xy)))), 1);\n}\n",It="struct Light {\n  position : vec3<f32>,\n  diffuse : vec3<f32>,\n  specular : vec3<f32>,\n}\n\nfn getAttenuation(dist : f32, constant : f32, linear : f32, quadratic : f32) -> f32 {\n  return 1.0 / (constant + linear * dist + quadratic * (dist * dist));\n}\n\nfn getDirectLight(light : Light, normal : vec3<f32>, position : vec3<f32>, shininess : f32) -> vec3<f32> {\n  let lightDir = normalize(light.position - position);\n  let viewDir : vec3<f32> = normalize(camera.position - position);\n  let halfwayDir : vec3<f32> = normalize(lightDir + viewDir);\n\n  let diffuse : vec3<f32> = max(dot(lightDir, normal), 0) * light.diffuse;\n  let specular : vec3<f32> = pow(max(dot(normal, halfwayDir), 0), shininess) * light.specular;\n\n  return diffuse + specular;\n}\n";class Ut{constructor({device:e,camera:t,format:n,time:o}){this.device=e,this.camera=t,this.format=n,this.time=o,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]}}render(e,t){const{bindings:n,descriptor:o,pipeline:r,uniforms:i}=this;o.colorAttachments[0].view=t;const s=e.beginRenderPass(o);s.setPipeline(r),s.setBindGroup(0,i),s.setBindGroup(1,n),s.draw(6),s.end()}bindTextures(){const{device:e,pipeline:t,textures:n}=this;t&&n&&(this.bindings=e.createBindGroup({layout:t.getBindGroupLayout(1),entries:[{binding:0,resource:n.color},{binding:1,resource:n.data},{binding:2,resource:n.position}]}))}setEffect(e){const{device:t,camera:n,format:o,time:r}=this;this.code=[n.constructor.WGSL,Rt,It,Tt,"// __SOURCE__",e].join("\n"),this.module=t.createShaderModule({code:this.code}),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{entryPoint:"vertex",module:this.module},fragment:{entryPoint:"fragment",module:this.module,targets:[{format:o}]},primitive:{topology:"triangle-list"}}),this.uniforms=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:r}}]}),this.bindTextures()}setTextures({color:e,data:t,position:n}){this.textures={color:e,data:t,position:n},this.bindTextures()}}class At{constructor({adapter:e,camera:t,device:n}){const o=navigator.gpu.getPreferredCanvasFormat(e);this.camera=t,this.device=n,this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:n,format:o}),this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:t.far},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}]},this.time=n.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.postprocessing=new Ut({device:n,camera:t,format:o,time:this.time}),this.scene=[],this.textures=new Map}render(e){const{context:t,descriptor:n,postprocessing:o,scene:r}=this,i=e.beginRenderPass(n);r.forEach((e=>e.render(i))),i.end(),o.render(e,t.getCurrentTexture().createView())}setSize(e,t,n=window.devicePixelRatio||1){const{camera:o,canvas:r,descriptor:i,postprocessing:s}=this,a=[Math.floor(e*n),Math.floor(t*n)];r.width=a[0],r.height=a[1],r.style.width=`${e}px`,r.style.height=`${t}px`,o.setSize(a[0],a[1]),this.updateTexture(i.colorAttachments[0],"rgba32float","color",a),this.updateTexture(i.colorAttachments[1],"rgba32float","data",a),this.updateTexture(i.colorAttachments[2],"rgba32float","position",a),s.setTextures({color:i.colorAttachments[0].view,data:i.colorAttachments[1].view,position:i.colorAttachments[2].view})}updateTexture(e,t,n,o){const{device:r,textures:i}=this,s=i.get(n);s&&s.destroy();const a=r.createTexture({format:t,size:o,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});e.view=a.createView(),i.set(n,a)}}function Gt(t){let n;return{c(){n=x("div"),S(n,"class","viewport svelte-vo8in0")},m(e,o){v(e,n,o),t[1](n)},p:e,i:e,o:e,d(e){e&&m(n),t[1](null)}}}function Nt(e,t,n){let o;return P((()=>{const{adapter:e,device:t}=le.gpu,n=new St({device:t}),r=new Pt({camera:n,target:o}),i=new At({adapter:e,camera:n,device:t});o.appendChild(i.canvas),i.setSize(window.innerWidth,window.innerHeight),i.setSize(r.bounds.width,r.bounds.height),window.addEventListener("resize",(()=>{r.updateBounds(),i.setSize(r.bounds.width,r.bounds.height)}),!1);const s=new Bt(i);i.scene.push(s);const a=new Float32Array([performance.now()/1e3]);document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(a[0]=performance.now()/1e3)}),!1);let c=!1;const l=()=>{requestAnimationFrame(l);const e=performance.now()/1e3,n=Math.min(e-a[0],1);if(a[0]=e,c)return;r.update(n),t.queue.writeBuffer(i.time,0,a);const o=t.createCommandEncoder();i.render(o),t.queue.submit([o.finish()])},f=({code:e,module:t},n)=>{c=!1;const o=e.split("\n"),r=o.indexOf("// __SOURCE__")+1;t.compilationInfo().then((({messages:e})=>n.set(e.map((({length:e,lineNum:t,linePos:n,message:i,type:s})=>(c=!0,{line:o[t-1],lineNum:t-r,linePos:n,length:e,message:i,pointer:Array.from({length:n-1+e},((e,t)=>t>=n-1?"^":" ")).join(""),type:s}))))))};le.input=r;const u=[le.iterations.subscribe((e=>s.setMaxIterations(e))),le.mode.subscribe((e=>s.setMode(e))),se.source.subscribe((e=>{i.postprocessing.setEffect(e),f(i.postprocessing,se.errors)})),ce.source.subscribe((e=>{s.setScene(e),f(s,ce.errors)}))];return requestAnimationFrame(l),()=>{u.forEach((e=>e())),le.input=null}})),[o,function(e){E[e?"unshift":"push"]((()=>{o=e,n(0,o)}))}]}class Ot extends te{constructor(e){super(),ee(this,e,Nt,Gt,i,{})}}const{window:jt}=K;function Vt(e){let t,n;return t=new Be({}),{c(){J(t.$$.fragment)},m(e,o){Z(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){H(t.$$.fragment,e),n=!1},d(e){Q(t,e)}}}function Wt(e){let t,n;return t=new be({}),{c(){J(t.$$.fragment)},m(e,o){Z(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){H(t.$$.fragment,e),n=!1},d(e){Q(t,e)}}}function Yt(e){let t,n;return t=new ge({}),{c(){J(t.$$.fragment)},m(e,o){Z(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){H(t.$$.fragment,e),n=!1},d(e){Q(t,e)}}}function Xt(e){let t,n,i,s,a,c,l,f,u,d,p,g,b;i=new ot({});const w=[Yt,Wt,Vt],F=[];function z(e,t){return"effect"===e[1]?0:"scene"===e[1]?1:"settings"===e[1]?2:-1}return~(a=z(e))&&(c=F[a]=w[a](e)),d=new Ot({}),{c(){t=x("div"),n=x("div"),J(i.$$.fragment),s=y(),c&&c.c(),l=y(),f=x("div"),u=y(),J(d.$$.fragment),S(n,"class","ui svelte-efpout"),M(n,"width",e[0].state+"px"),S(f,"class","divider svelte-efpout"),S(t,"class","app svelte-efpout")},m(o,c){v(o,t,c),h(t,n),Z(i,n,null),h(n,s),~a&&F[a].m(n,null),h(t,l),h(t,f),h(t,u),Z(d,t,null),p=!0,g||(b=[$(jt,"mousemove",(function(){r(e[0].enabled&&e[3])&&(e[0].enabled&&e[3]).apply(this,arguments)})),$(jt,"mouseup",(function(){r(e[0].enabled&&e[4])&&(e[0].enabled&&e[4]).apply(this,arguments)})),$(f,"mousedown",e[2])],g=!0)},p(t,[o]){let r=a;a=z(e=t),a!==r&&(c&&(W(),H(F[r],1,1,(()=>{F[r]=null})),Y()),~a?(c=F[a],c||(c=F[a]=w[a](e),c.c()),X(c,1),c.m(n,null)):c=null),(!p||1&o)&&M(n,"width",e[0].state+"px")},i(e){p||(X(i.$$.fragment,e),X(c),X(d.$$.fragment,e),p=!0)},o(e){H(i.$$.fragment,e),H(c),H(d.$$.fragment,e),p=!1},d(e){e&&m(t),Q(i),~a&&F[a].d(),Q(d),g=!1,o(b)}}}function Ht(e,t,n){let o;a(e,fe,(e=>n(1,o=e)));const r={enabled:!1,initial:0,offset:0,state:512};return[r,o,({clientX:e})=>{n(0,r.enabled=!0,r),n(0,r.initial=r.state,r),n(0,r.offset=e,r)},({clientX:e})=>{n(0,r.state=Math.max(Math.floor(r.initial+e-r.offset),320),r),I().then((()=>window.dispatchEvent(new Event("resize"))))},()=>{n(0,r.enabled=!1,r)}]}class Kt extends te{constructor(e){super(),ee(this,e,Ht,Xt,i,{})}}function Jt(e){let t,n;return t=new Kt({}),{c(){J(t.$$.fragment)},m(e,o){Z(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){H(t.$$.fragment,e),n=!1},d(e){Q(t,e)}}}function Zt(t){let n;return{c(){n=x("div"),n.innerHTML='Sorry! You&#39;ll need to try this in a browser with WebGPU support like <a href="https://www.google.com/chrome" rel="noopener noreferrer" target="_blank" class="svelte-1bwkh19">Chrome</a>.',S(n,"class","support svelte-1bwkh19")},m(e,t){v(e,n,t)},i:e,o:e,d(e){e&&m(n)}}}function Qt(t){let n;return{c(){n=x("div"),n.textContent="Loading...",S(n,"class","loading svelte-1bwkh19")},m(e,t){v(e,n,t)},i:e,o:e,d(e){e&&m(n)}}}function en(e){let t,n,o,r,i,s,a;const c=[Qt,Zt,Jt],l=[];function f(e,t){return e[1]?0:e[0]?1:2}return t=f(e),n=l[t]=c[t](e),{c(){n.c(),o=y(),r=x("div"),r.innerHTML='marcher - <a href="https://github.com/danielesteban/marcher" rel="noopener noreferrer" target="_blank" class="svelte-1bwkh19">view source</a><br/> \n  <a href="https://dani.gatunes.com" rel="noopener noreferrer" target="_blank" class="svelte-1bwkh19">dani@gatunes</a> © 2022',i=y(),s=x("a"),s.textContent="♥ Become a sponsor",S(r,"class","info svelte-1bwkh19"),S(s,"class","ribbon svelte-1bwkh19"),S(s,"href","https://github.com/sponsors/danielesteban"),S(s,"data-ribbon","♥ Become a sponsor"),S(s,"rel","noopener noreferrer"),S(s,"target","_blank")},m(e,n){l[t].m(e,n),v(e,o,n),v(e,r,n),v(e,i,n),v(e,s,n),a=!0},p(e,[r]){let i=t;t=f(e),t!==i&&(W(),H(l[i],1,1,(()=>{l[i]=null})),Y(),n=l[t],n||(n=l[t]=c[t](e),n.c()),X(n,1),n.m(o.parentNode,o))},i(e){a||(X(n),a=!0)},o(e){H(n),a=!1},d(e){l[t].d(e),e&&m(o),e&&m(r),e&&m(i),e&&m(s)}}}function tn(e,t,n){let o=!1,r=!0;return Promise.all([(async()=>{if(!navigator.gpu)throw new Error("WebGPU support");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU adapter");const t=await e.requestDevice();return{adapter:e,device:t}})(),new Promise((e=>{require.config({paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs"}}),require(["vs/editor/editor.main"],e)}))]).then((([e])=>{le.gpu=e})).catch((e=>{console.error(e),n(0,o=!0)})).finally((()=>{n(1,r=!1)})),[o,r]}new class extends te{constructor(e){super(),ee(this,e,tn,en,i,{})}}({target:document.body})}();
