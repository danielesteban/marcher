!function(){"use strict";function e(){}function t(e){return e()}function n(){return Object.create(null)}function o(e){e.forEach(t)}function r(e){return"function"==typeof e}function i(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function s(t,...n){if(null==t)return e;const o=t.subscribe(...n);return o.unsubscribe?()=>o.unsubscribe():o}function a(e){let t;return s(e,(e=>t=e))(),t}function c(e,t,n){e.$$.on_destroy.push(s(t,n))}function l(e,t,n,o){if(e){const r=f(e,t,n,o);return e[0](r)}}function f(e,t,n,o){return e[1]&&o?function(e,t){for(const n in t)e[n]=t[n];return e}(n.ctx.slice(),e[1](o(t))):n.ctx}function u(e,t,n,o){if(e[2]&&o){const r=e[2](o(n));if(void 0===t.dirty)return r;if("object"==typeof r){const e=[],n=Math.max(t.dirty.length,r.length);for(let o=0;o<n;o+=1)e[o]=t.dirty[o]|r[o];return e}return t.dirty|r}return t.dirty}function d(e,t,n,o,r,i){if(r){const s=f(t,n,o,i);e.p(s,r)}}function p(e){if(e.ctx.length>32){const t=[],n=e.ctx.length/32;for(let e=0;e<n;e++)t[e]=-1;return t}return-1}function v(e,t,n){return e.set(n),t}function h(e,t){e.appendChild(t)}function m(e,t,n){e.insertBefore(t,n||null)}function g(e){e.parentNode.removeChild(e)}function x(e,t){for(let n=0;n<e.length;n+=1)e[n]&&e[n].d(t)}function b(e){return document.createElement(e)}function y(e){return document.createTextNode(e)}function w(){return y(" ")}function $(){return y("")}function S(e,t,n,o){return e.addEventListener(t,n,o),()=>e.removeEventListener(t,n,o)}function k(e,t,n){null==n?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function M(e,t){t=""+t,e.wholeText!==t&&(e.data=t)}function F(e,t,n,o){null===n?e.style.removeProperty(t):e.style.setProperty(t,n,o?"important":"")}function L(e,t){for(let n=0;n<e.options.length;n+=1){const o=e.options[n];if(o.__value===t)return void(o.selected=!0)}e.selectedIndex=-1}function D(e,t,n){e.classList[n?"add":"remove"](t)}let z;function P(e){z=e}function E(e){(function(){if(!z)throw new Error("Function called outside component initialization");return z})().$$.on_mount.push(e)}const _=[],q=[],T=[],C=[],B=Promise.resolve();let R=!1;function U(){R||(R=!0,B.then(j))}function I(){return U(),B}function A(e){T.push(e)}const N=new Set;let O=0;function j(){const e=z;do{for(;O<_.length;){const e=_[O];O++,P(e),G(e.$$)}for(P(null),_.length=0,O=0;q.length;)q.pop()();for(let e=0;e<T.length;e+=1){const t=T[e];N.has(t)||(N.add(t),t())}T.length=0}while(_.length);for(;C.length;)C.pop()();R=!1,N.clear(),P(e)}function G(e){if(null!==e.fragment){e.update(),o(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(A)}}const V=new Set;let W;function Y(){W={r:0,c:[],p:W}}function H(){W.r||o(W.c),W=W.p}function X(e,t){e&&e.i&&(V.delete(e),e.i(t))}function K(e,t,n,o){if(e&&e.o){if(V.has(e))return;V.add(e),W.c.push((()=>{V.delete(e),o&&(n&&e.d(1),o())})),e.o(t)}else o&&o()}const J="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function Z(e){e&&e.c()}function Q(e,n,i,s){const{fragment:a,on_mount:c,on_destroy:l,after_update:f}=e.$$;a&&a.m(n,i),s||A((()=>{const n=c.map(t).filter(r);l?l.push(...n):o(n),e.$$.on_mount=[]})),f.forEach(A)}function ee(e,t){const n=e.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function te(t,r,i,s,a,c,l,f=[-1]){const u=z;P(t);const d=t.$$={fragment:null,ctx:null,props:c,update:e,not_equal:a,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(r.context||(u?u.$$.context:[])),callbacks:n(),dirty:f,skip_bound:!1,root:r.target||u.$$.root};l&&l(d.root);let p=!1;if(d.ctx=i?i(t,r.props||{},((e,n,...o)=>{const r=o.length?o[0]:n;return d.ctx&&a(d.ctx[e],d.ctx[e]=r)&&(!d.skip_bound&&d.bound[e]&&d.bound[e](r),p&&function(e,t){-1===e.$$.dirty[0]&&(_.push(e),U(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}(t,e)),n})):[],d.update(),p=!0,o(d.before_update),d.fragment=!!s&&s(d.ctx),r.target){if(r.hydrate){const e=function(e){return Array.from(e.childNodes)}(r.target);d.fragment&&d.fragment.l(e),e.forEach(g)}else d.fragment&&d.fragment.c();r.intro&&X(t.$$.fragment),Q(t,r.target,r.anchor,r.customElement),j()}P(u)}class ne{$destroy(){ee(this,1),this.$destroy=e}$on(e,t){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const oe=[];function re(t,n=e){let o;const r=new Set;function s(e){if(i(t,e)&&(t=e,o)){const e=!oe.length;for(const e of r)e[1](),oe.push(e,t);if(e){for(let e=0;e<oe.length;e+=2)oe[e][0](oe[e+1]);oe.length=0}}}return{set:s,update:function(e){s(e(t))},subscribe:function(i,a=e){const c=[i,a];return r.add(c),1===r.size&&(o=n(s)||e),i(t),()=>{r.delete(c),0===r.size&&(o(),o=null)}}}}const ie=(e,t)=>{e=`marcher:${e}`;const n=localStorage.getItem(e),{subscribe:o,set:r}=re(n?JSON.parse(n):t);return{subscribe:o,set:t=>{r(t),localStorage.setItem(e,JSON.stringify(t))}}},se=["const background : vec3<f32> = vec3<f32>(0, 0, 0);\nconst fogDensity : f32 = 0.005;\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, background, 1 - exp(-fogDensity * fogDensity * depth * depth) * color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  return (\n    0.1\n    + getDirectLight(Light(position + vec3<f32>(0, 1, 0), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.5\n    + getDirectLight(Light(position + vec3<f32>(1, 1, 1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n    + getDirectLight(Light(position + vec3<f32>(-1, 1, -1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n  );\n}\n","const background : vec3<f32> = vec3<f32>(0, 0, 0);\nconst fogDensity : f32 = 0.005;\n\nconst edgeColor : vec3<f32> = vec3<f32>(0, 0, 0);\nconst edgeIntensity : f32 = 0.5;\nconst depthScale : f32 = 0.5;\nconst depthBias : f32 = 1;\nconst normalBias : f32 = 10;\nconst normalScale : f32 = 0.5;\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, edgeColor, getEdge(pixel, data) * edgeIntensity);\n  out = mix(out, background, 1 - exp(-fogDensity * fogDensity * depth * depth) * color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  return (\n    0.1\n    + getDirectLight(Light(position + vec3<f32>(0, 1, 0), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.5\n    + getDirectLight(Light(position + vec3<f32>(1, 1, 1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n    + getDirectLight(Light(position + vec3<f32>(-1, 1, -1), vec3<f32>(1), vec3<f32>(0.3)), normal, position, 32) * 0.25\n  );\n}\n\nfn getEdge(pixel : vec2<i32>, data : vec4<f32>) -> f32 {\n  const offset : vec3<i32> = vec3<i32>(1, 1, 0);\n  let dataLeft : vec4<f32> = textureLoad(dataTexture, pixel - offset.xz, 0);\n  let dataRight : vec4<f32> = textureLoad(dataTexture, pixel + offset.xz, 0);\n  let dataUp : vec4<f32> = textureLoad(dataTexture, pixel + offset.zy, 0);\n  let dataDown : vec4<f32> = textureLoad(dataTexture, pixel - offset.zy, 0);\n  let edge : vec4<f32> = (\n    abs(dataLeft - data)\n    + abs(dataRight - data) \n    + abs(dataUp - data) \n    + abs(dataDown - data)\n  );\n  return clamp(max(pow((edge.x + edge.y + edge.z) * normalScale, normalBias), pow(edge.w * depthScale, depthBias)), 0, 1);\n}\n","const background : vec3<f32> = vec3<f32>(0, 0, 0);\nconst fogDensity : f32 = 0.005;\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, background, 1 - exp(-fogDensity * fogDensity * depth * depth) * color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  let light : Light = Light(\n    camera.position,\n    vec3<f32>(1, 1, 1),\n    vec3<f32>(0.3)\n  );\n  let theta = dot(camera.direction, -normalize(light.position - position));\n  return (\n    (\n      getDirectLight(light, normal, position, 128)\n      * getAttenuation(distance(light.position, position), 1, 0.007, 0.0002)\n      * clamp((theta - PI * 0.2) / (PI * 0.5), 0, 1)\n    )\n  );\n}\n","const background : vec3<f32> = vec3<f32>(0, 0, 0);\n\nfn getEffect(pixel : vec2<i32>) -> vec3<f32> {\n  let data : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let depth : f32 = data.w;\n  if (depth >= camera.far) {\n    return background;\n  }\n  let color : vec4<f32> = textureLoad(colorTexture, pixel, 0);\n  let position : vec3<f32> = textureLoad(positionTexture, pixel, 0).xyz;\n  var out : vec3<f32> = color.xyz * getLight(data.xyz, position);\n  out = mix(out, background, 1 - color.w);\n  return out;\n}\n\nfn getLight(normal : vec3<f32>, position : vec3<f32>) -> vec3<f32> {\n  const target : vec3<f32> = vec3<f32>(0, 0, -8);\n  let lights : array<Light, 2> = array<Light, 2>(\n    Light(\n      target + spherical(PI * 0.25, time, 8),\n      vec3<f32>(0.8, 0.4, 0),\n      vec3<f32>(0.3)\n    ),\n    Light(\n      target + spherical(PI * 0.25, time - PI, 8),\n      vec3<f32>(0, 0.2, 0.8),\n      vec3<f32>(0.3)\n    ),\n  );\n  var light : vec3<f32> = vec3<f32>(0.01);\n  for (var i : u32 = 0; i < 2; i++) {\n    light += (\n      getDirectLight(lights[i], normal, position, 32)\n      * getAttenuation(distance(lights[i].position, position), 1, 0.09, 0.032)\n    );\n  }\n  return light;\n}\n"],ae={editor:null,errors:re([]),source:ie("effect",se[0])},ce=["fn getScene(pos : vec3<f32>) -> SDF {\n  let q : vec3<f32> = pos - vec3<f32>(0, 0, -8);\n  let d : f32 = sin(q.x * 10) * sin(q.y * 10) * sin(q.z * 10) * 0.1;\n  return SDF(\n    vec3<f32>(1, 1, 1) - vec3<f32>(d * 10, d * 5, d * 5),\n    sdSphere(q, 4) + d\n  );\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  let q : vec3<f32> = pos - vec3<f32>(0, 0, -8);\n  let d : f32 = sin(q.x * 10) * sin(q.y * 10) * sin(q.z * 10) * 0.1;\n\n  let a : SDF = SDF(\n    vec3<f32>(1, 1, 1) - vec3<f32>(d * 10, d * 5, d * 5),\n    sdSphere(q, 4) + d\n  );\n\n  let b : SDF = SDF(\n    clamp(vec3<f32>(0.5, 0.5, 0.5) + vec3<f32>(d * 10, d * 5, d * 5), vec3<f32>(0), vec3<f32>(1)),\n    sdSphere(q - vec3<f32>(0, 0, 4), 2) + d\n  );\n\n  return opSmoothSubstraction(a, b, 0.15);\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  var scene : SDF = SDF(\n    vec3<f32>(.8, .1, .05),\n    sdBox(rotateY(PI * 0.25) * rotateX(PI * 0.25) * (pos - vec3<f32>(-7, 0, -10)), vec3<f32>(1, 1, 1))\n  );\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.8, .2, .05),\n    sdCapsule(pos - vec3<f32>(-3.5, 0, -10), vec2<f32>(0.5, 2))\n  ));\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.2, .2, .8),\n    sdSphere(pos - vec3<f32>(0, 0, -10), 1)\n  ));\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.8, .2, .05),\n    sdEllipsoid(pos - vec3<f32>(3.5, 0, -10), vec3<f32>(1, 2, 1))\n  ));\n  scene = opUnion(scene, SDF(\n    vec3<f32>(.8, .1, .05),\n    sdTorus(rotateX(PI * 0.5) * (pos - vec3<f32>(7, 0, -10)), vec2<f32>(1, 0.25))\n  ));\n  scene = opSmoothUnion(scene, SDF(\n    vec3<f32>(0.8, 0.8, 0.1),\n    sdPlane(pos, vec3<f32>(0, 1, 0), 1.5)\n  ), 1);\n  return scene;\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  const r : vec3<f32> = vec3<f32>(8, 8, 8);\n  let q = abs(pos % r) - r * 0.5;\n\n  let id : vec3<f32> = floor(pos / r);\n  let n = SimplexNoise(id);\n  let s = 1 + sin(id.x * id.y * id.z);\n  let di = 2 + (abs(id.x + id.y + id.z) % 8);\n  let d = sin(pos.x * di) * sin(pos.y * di) * sin(pos.z * di) * 0.1;\n\n  let a = SDF(\n    getColor(u32(abs(n + 0.5) * 0xFFFFFF)),\n    sdSphere(q + sin(id + time * 0.5) * (s * 0.5), s) + d\n  );\n  let b = SDF(\n    getColor(u32(abs(n - 0.5) * 0xFFFFFF)),\n    sdSphere(q - sin(id + time * sin(id.x + id.z) * 0.5) * (s * 0.5), s) - d\n  );\n  return opSmoothUnion(a, b, 1);\n}\n\nfn getColor(c : u32) -> vec3<f32> {\n  return vec3<f32>(\n    f32((c >> 16) & 0xFF) / 0xFF,\n    f32((c >> 8) & 0xFF) / 0xFF,\n    f32(c & 0xFF) / 0xFF,\n  );\n}\n","fn getScene(pos : vec3<f32>) -> SDF {\n  let q = pos - vec3<f32>(0, 0, -64);\n  let n = abs(FBM(q * (0.06 + sin(time * 0.5) * 0.01) - 0.2));\n  return SDF(\n    hsl2Rgb(vec3<f32>(n, 0.7, 0.5)),\n    sdSphere(q, 32 - n * 8)\n  );\n}\n\nfn FBM(p : vec3<f32>) -> f32 {\n  var value : f32;\n  var amplitude : f32 = 0.5;\n  var q : vec3<f32> = p;\n  for (var i : i32 = 0; i < 3; i++) {\n    value += SimplexNoise(q) * amplitude;\n    q *= 2;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n"],le={editor:null,errors:re([]),source:ie("scene",ce[0])},fe={gpu:null,input:null,iterations:ie("iterations",300),mode:ie("mode","raymarching")},ue=re("scene");function de(e,t,n){const o=e.slice();return o[11]=t[n].lineNum,o[12]=t[n].linePos,o[13]=t[n].type,o[14]=t[n].message,o[15]=t[n].line,o[16]=t[n].pointer,o}function pe(e){let t,n,o,r,i,s,a,c,l,f,u,d,p,v,x,$,S,F=e[11]+"",L=e[12]+"",D=e[13]+"",z=e[14]+"",P=e[15]+"",E=e[16]+"";return{c(){t=b("div"),n=b("div"),o=y(":"),r=y(F),i=y(":"),s=y(L),a=w(),c=y(D),l=y(": "),f=y(z),u=w(),d=b("div"),p=y(P),v=w(),x=b("div"),$=y(E),S=w(),k(n,"class","svelte-1s5oj1u"),k(d,"class","svelte-1s5oj1u"),k(x,"class","svelte-1s5oj1u"),k(t,"class","svelte-1s5oj1u")},m(e,g){m(e,t,g),h(t,n),h(n,o),h(n,r),h(n,i),h(n,s),h(n,a),h(n,c),h(n,l),h(n,f),h(t,u),h(t,d),h(d,p),h(t,v),h(t,x),h(x,$),h(t,S)},p(e,t){4&t&&F!==(F=e[11]+"")&&M(r,F),4&t&&L!==(L=e[12]+"")&&M(s,L),4&t&&D!==(D=e[13]+"")&&M(c,D),4&t&&z!==(z=e[14]+"")&&M(f,z),4&t&&P!==(P=e[15]+"")&&M(p,P),4&t&&E!==(E=e[16]+"")&&M($,E)},d(e){e&&g(t)}}}function ve(t){let n,o,r,i,s,a,c,l,f,u,d,p,v,$,F=t[2].length+"",L=t[2],z=[];for(let e=0;e<L.length;e+=1)z[e]=pe(de(t,L,e));return{c(){n=b("div"),o=b("div"),r=w(),i=b("div"),s=b("div"),a=b("div"),c=w(),l=y(F),f=y(" errors\n      "),u=b("div"),d=w(),p=b("div");for(let e=0;e<z.length;e+=1)z[e].c();k(o,"class","wrapper svelte-1s5oj1u"),k(a,"class","status svelte-1s5oj1u"),D(a,"error",t[2].length),k(u,"class","arrow svelte-1s5oj1u"),k(s,"class","toggle svelte-1s5oj1u"),k(p,"class","messages svelte-1s5oj1u"),k(i,"class","errors svelte-1s5oj1u"),D(i,"open",t[1]),k(n,"class","editor svelte-1s5oj1u")},m(e,g){m(e,n,g),h(n,o),t[7](o),h(n,r),h(n,i),h(i,s),h(s,a),h(s,c),h(s,l),h(s,f),h(s,u),h(i,d),h(i,p);for(let e=0;e<z.length;e+=1)z[e].m(p,null);v||($=S(s,"click",t[5]),v=!0)},p(e,[t]){if(4&t&&D(a,"error",e[2].length),4&t&&F!==(F=e[2].length+"")&&M(l,F),4&t){let n;for(L=e[2],n=0;n<L.length;n+=1){const o=de(e,L,n);z[n]?z[n].p(o,t):(z[n]=pe(o),z[n].c(),z[n].m(p,null))}for(;n<z.length;n+=1)z[n].d(1);z.length=L.length}2&t&&D(i,"open",e[1])},i:e,o:e,d(e){e&&g(n),t[7](null),x(z,e),v=!1,$()}}}function he(e,t,n){let o,r,{state:i}=t;const{errors:s,source:a}=i;let l,f;c(e,s,(e=>n(2,r=e))),c(e,a,(e=>n(9,o=e)));let u=!1;const d=()=>f.layout();return E((()=>{let e,t=!0,r=!1;if(f=monaco.editor.create(l,{minimap:{enabled:!1},theme:"vs-dark"}),i.editor){const{model:e,view:t}=i.editor;f.setModel(e),f.restoreViewState(t)}else f.setModel(monaco.editor.createModel(o,"c"));const c=[s.subscribe((e=>{monaco.editor.setModelMarkers(f.getModel(),"Errors",e.map((({lineNum:e,linePos:t,length:n,message:o})=>({message:o,startLineNumber:e,endLineNumber:e,startColumn:t,endColumn:t+n}))))})),a.subscribe((e=>{t||(r=!0,f.setValue(e),r=!1)}))];return t=!1,f.onDidChangeModelContent((()=>{r||(e&&clearTimeout(e),e=setTimeout((()=>{t=!0,a.set(f.getValue()),t=!1}),300))})),f.focus(),window.addEventListener("resize",d,!1),()=>{n(6,i.editor={model:f.getModel(),view:f.saveViewState()},i),f.dispose(),clearTimeout(e),window.removeEventListener("resize",d),c.forEach((e=>e()))}})),e.$$set=e=>{"state"in e&&n(6,i=e.state)},[l,u,r,s,a,()=>{n(1,u=!u),I().then(d)},i,function(e){q[e?"unshift":"push"]((()=>{l=e,n(0,l)}))}]}class me extends ne{constructor(e){super(),te(this,e,he,ve,i,{state:6})}}function ge(t){let n,o;return n=new me({props:{state:ae}}),{c(){Z(n.$$.fragment)},m(e,t){Q(n,e,t),o=!0},p:e,i(e){o||(X(n.$$.fragment,e),o=!0)},o(e){K(n.$$.fragment,e),o=!1},d(e){ee(n,e)}}}class xe extends ne{constructor(e){super(),te(this,e,null,ge,i,{})}}function be(t){let n,o;return n=new me({props:{state:le}}),{c(){Z(n.$$.fragment)},m(e,t){Q(n,e,t),o=!0},p:e,i(e){o||(X(n.$$.fragment,e),o=!0)},o(e){K(n.$$.fragment,e),o=!1},d(e){ee(n,e)}}}class ye extends ne{constructor(e){super(),te(this,e,null,be,i,{})}}function we(t){let n,o,r;return{c(){n=b("input"),k(n,"type","number"),k(n,"id",t[0]),k(n,"max",t[1]),k(n,"min",t[2]),k(n,"step",t[3]),n.value=t[5],k(n,"class","svelte-io5ur8")},m(e,i){m(e,n,i),o||(r=S(n,"input",t[6]),o=!0)},p(e,[t]){1&t&&k(n,"id",e[0]),2&t&&k(n,"max",e[1]),4&t&&k(n,"min",e[2]),8&t&&k(n,"step",e[3]),32&t&&n.value!==e[5]&&(n.value=e[5])},i:e,o:e,d(e){e&&g(n),o=!1,r()}}}function $e(t,n,o){let r,i=e,a=()=>(i(),i=s(d,(e=>o(5,r=e))),d);t.$$.on_destroy.push((()=>i()));let{id:c}=n,{max:l}=n,{min:f}=n,{step:u}=n,{state:d}=n;a();return t.$$set=e=>{"id"in e&&o(0,c=e.id),"max"in e&&o(1,l=e.max),"min"in e&&o(2,f=e.min),"step"in e&&o(3,u=e.step),"state"in e&&a(o(4,d=e.state))},[c,l,f,u,d,r,({target:{value:e}})=>{v(d,r=parseInt(e,10),r)}]}class Se extends ne{constructor(e){super(),te(this,e,$e,we,i,{id:0,max:1,min:2,step:3,state:4})}}function ke(e,t,n){const o=e.slice();return o[2]=t[n].id,o[5]=t[n].name,o}function Me(e){let t,n,o,r=e[5]+"";return{c(){t=b("option"),n=y(r),t.__value=o=e[2],t.value=t.__value},m(e,o){m(e,t,o),h(t,n)},p(e,i){1&i&&r!==(r=e[5]+"")&&M(n,r),1&i&&o!==(o=e[2])&&(t.__value=o,t.value=t.__value)},d(e){e&&g(t)}}}function Fe(t){let n,o,r,i=t[0],s=[];for(let e=0;e<i.length;e+=1)s[e]=Me(ke(t,i,e));return{c(){n=b("select");for(let e=0;e<s.length;e+=1)s[e].c();k(n,"id",t[2]),k(n,"class","svelte-146trro"),void 0===t[3]&&A((()=>t[4].call(n)))},m(e,i){m(e,n,i);for(let e=0;e<s.length;e+=1)s[e].m(n,null);L(n,t[3]),o||(r=S(n,"change",t[4]),o=!0)},p(e,[t]){if(1&t){let o;for(i=e[0],o=0;o<i.length;o+=1){const r=ke(e,i,o);s[o]?s[o].p(r,t):(s[o]=Me(r),s[o].c(),s[o].m(n,null))}for(;o<s.length;o+=1)s[o].d(1);s.length=i.length}4&t&&k(n,"id",e[2]),9&t&&L(n,e[3])},i:e,o:e,d(e){e&&g(n),x(s,e),o=!1,r()}}}function Le(t,n,o){let r,i=e,a=()=>(i(),i=s(f,(e=>o(3,r=e))),f);t.$$.on_destroy.push((()=>i()));let{id:c}=n,{options:l}=n,{state:f}=n;return a(),t.$$set=e=>{"id"in e&&o(2,c=e.id),"options"in e&&o(0,l=e.options),"state"in e&&a(o(1,f=e.state))},[l,f,c,r,function(){r=function(e){const t=e.querySelector(":checked")||e.options[0];return t&&t.__value}(this),f.set(r),o(0,l)}]}class De extends ne{constructor(e){super(),te(this,e,Le,Fe,i,{id:2,options:0,state:1})}}function ze(e,t,n){const o=e.slice();return o[5]=t[n].id,o[6]=t[n].name,o}function Pe(e,t,n){const o=e.slice();return o[6]=t[n].name,o[9]=t[n].items,o}function Ee(e,t,n){const o=e.slice();return o[12]=t[n],o}function _e(t){let n,o,r=t[12]+"";return{c(){n=b("div"),o=y(r)},m(e,t){m(e,n,t),h(n,o)},p:e,d(e){e&&g(n)}}}function qe(e){let t,n,o,r,i,s,a=e[6]+"",c=e[9],l=[];for(let t=0;t<c.length;t+=1)l[t]=_e(Ee(e,c,t));return{c(){t=b("div"),n=b("div"),o=y(a),r=w(),i=b("div");for(let e=0;e<l.length;e+=1)l[e].c();s=w(),k(n,"class","svelte-13z9b40"),k(i,"class","svelte-13z9b40"),k(t,"class","svelte-13z9b40")},m(e,a){m(e,t,a),h(t,n),h(n,o),h(t,r),h(t,i);for(let e=0;e<l.length;e+=1)l[e].m(i,null);h(t,s)},p(e,t){if(16&t){let n;for(c=e[9],n=0;n<c.length;n+=1){const o=Ee(e,c,n);l[n]?l[n].p(o,t):(l[n]=_e(o),l[n].c(),l[n].m(i,null))}for(;n<l.length;n+=1)l[n].d(1);l.length=c.length}},d(e){e&&g(t),x(l,e)}}}function Te(t){let n,o,r,i,s,a,c,l=t[5]+"",f=t[6]+"";return{c(){n=b("div"),o=b("div"),r=y(l),i=w(),s=b("div"),a=y(f),c=w(),k(o,"class","svelte-13z9b40"),k(s,"class","svelte-13z9b40"),k(n,"class","svelte-13z9b40")},m(e,t){m(e,n,t),h(n,o),h(o,r),h(n,i),h(n,s),h(s,a),h(n,c)},p:e,d(e){e&&g(n)}}}function Ce(e){let t,n,o,r,i,s,a,c,l,f,u,d,p,v,y,$,S,M,F;i=new De({props:{id:"mode",options:e[3],state:e[1]}}),f=new Se({props:{id:"iterations",state:e[0],step:100,min:100,max:1e3}});let L=e[4],D=[];for(let t=0;t<L.length;t+=1)D[t]=qe(Pe(e,L,t));let z=e[2],P=[];for(let t=0;t<z.length;t+=1)P[t]=Te(ze(e,z,t));return{c(){t=b("div"),n=b("div"),o=b("label"),o.textContent="Mode:",r=w(),Z(i.$$.fragment),s=w(),a=b("div"),c=b("label"),c.textContent="Max iterations:",l=w(),Z(f.$$.fragment),u=w(),d=b("div"),d.textContent="Reference",p=w(),v=b("div");for(let e=0;e<D.length;e+=1)D[e].c();y=w(),$=b("div"),$.textContent="Controls",S=w(),M=b("div");for(let e=0;e<P.length;e+=1)P[e].c();k(o,"for","mode"),k(o,"class","svelte-13z9b40"),k(n,"class","input svelte-13z9b40"),k(c,"for","iterations"),k(c,"class","svelte-13z9b40"),k(a,"class","input svelte-13z9b40"),k(d,"class","heading svelte-13z9b40"),k(v,"class","reference svelte-13z9b40"),k($,"class","heading svelte-13z9b40"),k(M,"class","controls svelte-13z9b40"),k(t,"class","wrapper svelte-13z9b40")},m(e,g){m(e,t,g),h(t,n),h(n,o),h(n,r),Q(i,n,null),h(t,s),h(t,a),h(a,c),h(a,l),Q(f,a,null),h(t,u),h(t,d),h(t,p),h(t,v);for(let e=0;e<D.length;e+=1)D[e].m(v,null);h(t,y),h(t,$),h(t,S),h(t,M);for(let e=0;e<P.length;e+=1)P[e].m(M,null);F=!0},p(e,[t]){if(16&t){let n;for(L=e[4],n=0;n<L.length;n+=1){const o=Pe(e,L,n);D[n]?D[n].p(o,t):(D[n]=qe(o),D[n].c(),D[n].m(v,null))}for(;n<D.length;n+=1)D[n].d(1);D.length=L.length}if(4&t){let n;for(z=e[2],n=0;n<z.length;n+=1){const o=ze(e,z,n);P[n]?P[n].p(o,t):(P[n]=Te(o),P[n].c(),P[n].m(M,null))}for(;n<P.length;n+=1)P[n].d(1);P.length=z.length}},i(e){F||(X(i.$$.fragment,e),X(f.$$.fragment,e),F=!0)},o(e){K(i.$$.fragment,e),K(f.$$.fragment,e),F=!1},d(e){e&&g(t),ee(i),ee(f),x(D,e),x(P,e)}}}function Be(e){const{iterations:t,mode:n}=fe;return[t,n,[{id:"W",name:"Move forwards"},{id:"A",name:"Move leftwards"},{id:"S",name:"Move backwards"},{id:"D",name:"Move rightwards"},{id:"Q",name:"Move downwards"},{id:"E",name:"Move upwards"},{id:"R",name:"Reset camera"},{id:"Shift",name:"Double movement speed"},{id:"Wheel",name:"Set movement speed"}],[{id:"raymarching",name:"Raymarching (better performance)"},{id:"conetracing",name:"Conetracing (better antialiasing)"}],[{name:"Color",items:["fn hsl2Rgb(hsl : vec3<f32>) -> vec3<f32>"]},{name:"Light",items:["struct Light { position : vec3<f32>, diffuse : vec3<f32>, specular : vec3<f32> }","fn getAttenuation(dist : f32, constant : f32, linear : f32, quadratic : f32) -> f32","fn getDirectLight(light : Light, normal : vec3<f32>, position : vec3<f32>, shininess : f32) -> vec3<f32>"]},{name:"Noise",items:["fn SimplexNoise(v : vec3<f32>) -> f32"]},{name:"Rotation",items:["const PI : f32","fn rotateX(radians : f32) -> mat3x3<f32>","fn rotateY(radians : f32) -> mat3x3<f32>","fn rotateZ(radians : f32) -> mat3x3<f32>","fn spherical(phi : f32, theta : f32, radius : f32) -> vec3<f32>"]},{name:"SDF",items:["struct SDF { color : vec3<f32>, distance : f32 }","fn opUnion(a : SDF, b : SDF) -> SDF","fn opSubstraction(a : SDF, b : SDF) -> SDF","fn opSmoothUnion(a : SDF, b : SDF, k : f32) -> SDF","fn opSmoothSubstraction(a : SDF, b : SDF, k : f32) -> SDF","fn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32","fn sdCapsule(p : vec3<f32>, r : vec2<f32>) -> f32","fn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32","fn sdPlane(p : vec3<f32>, n : vec3<f32>, h : f32) -> f32","fn sdSphere(p : vec3<f32>, r : f32) -> f32","fn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32"]},{name:"Uniforms",items:["struct Camera {","inverseMatrix : mat4x4<f32>,","position : vec3<f32>,","direction : vec3<f32>,","cone : f32,","near : f32,","far : f32,","}","var<uniform> camera : Camera;","var<uniform> time : f32;"]}]]}class Re extends ne{constructor(e){super(),te(this,e,Be,Ce,i,{})}}const Ue=e=>({}),Ie=e=>({}),Ae=e=>({}),Ne=e=>({});function Oe(e){let t,n,o,r;const i=e[1].toggle,s=l(i,e,e[0],Ne),a=e[1].options,c=l(a,e,e[0],Ie);return{c(){t=b("div"),s&&s.c(),n=w(),o=b("div"),c&&c.c(),k(o,"class","options svelte-7xzgh1"),k(t,"class","dropdown svelte-7xzgh1")},m(e,i){m(e,t,i),s&&s.m(t,null),h(t,n),h(t,o),c&&c.m(o,null),r=!0},p(e,[t]){s&&s.p&&(!r||1&t)&&d(s,i,e,e[0],r?u(i,e[0],t,Ae):p(e[0]),Ne),c&&c.p&&(!r||1&t)&&d(c,a,e,e[0],r?u(a,e[0],t,Ue):p(e[0]),Ie)},i(e){r||(X(s,e),X(c,e),r=!0)},o(e){K(s,e),K(c,e),r=!1},d(e){e&&g(t),s&&s.d(e),c&&c.d(e)}}}function je(e,t,n){let{$$slots:o={},$$scope:r}=t;return e.$$set=e=>{"$$scope"in e&&n(0,r=e.$$scope)},[r,o]}class Ge extends ne{constructor(e){super(),te(this,e,je,Oe,i,{})}}function Ve(t){let n;return{c(){n=b("div"),n.innerHTML='<div class="arrow svelte-1xvkg86"></div> \n    <div class="label svelte-1xvkg86">File</div>',k(n,"class","toggle svelte-1xvkg86"),k(n,"slot","toggle")},m(e,t){m(e,n,t)},p:e,d(e){e&&g(n)}}}function We(t){let n,r,i,s,a;return{c(){n=b("div"),n.textContent="Import",r=w(),i=b("div"),i.textContent="Export",k(n,"class","action svelte-1xvkg86"),k(i,"class","action svelte-1xvkg86")},m(e,o){m(e,n,o),m(e,r,o),m(e,i,o),s||(a=[S(n,"click",t[2]),S(i,"click",t[4])],s=!0)},p:e,d(e){e&&g(n),e&&g(r),e&&g(i),s=!1,o(a)}}}function Ye(e){let t,n,o,r,i,s,a,c,l;return s=new Ge({props:{$$slots:{options:[We],toggle:[Ve]},$$scope:{ctx:e}}}),{c(){t=b("div"),n=b("input"),o=w(),r=b("a"),i=w(),Z(s.$$.fragment),k(n,"type","file"),k(n,"accept","application/json"),k(t,"class","helpers svelte-1xvkg86")},m(f,u){m(f,t,u),h(t,n),e[5](n),h(t,o),h(t,r),e[6](r),m(f,i,u),Q(s,f,u),a=!0,c||(l=S(n,"change",e[3]),c=!0)},p(e,[t]){const n={};512&t&&(n.$$scope={dirty:t,ctx:e}),s.$set(n)},i(e){a||(X(s.$$.fragment,e),a=!0)},o(e){K(s.$$.fragment,e),a=!1},d(n){n&&g(t),e[5](null),e[6](null),n&&g(i),ee(s,n),c=!1,l()}}}function He(e,t,n){let o,r;return[o,r,()=>o.click(),()=>{const e=o.files[0];if(!e)return;const t=new FileReader;t.addEventListener("load",(()=>{n(0,o.value=null,o);const e=JSON.parse(t.result);ae.editor=null,ae.source.set(e.effect),le.editor=null,le.source.set(e.scene)}),!1),t.readAsText(e)},()=>{const e=new Blob([JSON.stringify({effect:a(ae.source),scene:a(le.source),version:1})],{type:"application/json"}),t=new Date,o=e=>("00"+e).slice(-2),i=`${o(t.getMonth()+1)}${o(t.getDate())}`,s=`${o(t.getHours())}${o(t.getMinutes())}`;n(1,r.download=`marcher-${i}${s}.json`,r),n(1,r.href=URL.createObjectURL(e),r),r.click()},function(e){q[e?"unshift":"push"]((()=>{o=e,n(0,o)}))},function(e){q[e?"unshift":"push"]((()=>{r=e,n(1,r)}))}]}class Xe extends ne{constructor(e){super(),te(this,e,He,Ye,i,{})}}function Ke(e,t,n){const o=e.slice();return o[7]=t[n],o[9]=n,o}function Je(e,t,n){const o=e.slice();return o[7]=t[n],o[9]=n,o}function Ze(e,t,n){const o=e.slice();return o[11]=t[n].id,o[12]=t[n].name,o}function Qe(e){let t,n,o,r,i,s=e[12]+"";return{c(){t=b("div"),n=y(s),o=w(),k(t,"class","view svelte-uki0cf"),D(t,"enabled",e[0]===e[11])},m(s,a){m(s,t,a),h(t,n),h(t,o),r||(i=S(t,"click",e[4](e[11])),r=!0)},p(n,o){e=n,3&o&&D(t,"enabled",e[0]===e[11])},d(e){e&&g(t),r=!1,i()}}}function et(e){let t,n;return t=new Ge({props:{$$slots:{options:[st],toggle:[tt]},$$scope:{ctx:e}}}),{c(){Z(t.$$.fragment)},m(e,o){Q(t,e,o),n=!0},p(e,n){const o={};32769&n&&(o.$$scope={dirty:n,ctx:e}),t.$set(o)},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){K(t.$$.fragment,e),n=!1},d(e){ee(t,e)}}}function tt(t){let n;return{c(){n=b("div"),n.innerHTML='<div class="label svelte-uki0cf">Examples</div> \n          <div class="arrow svelte-uki0cf"></div>',k(n,"class","toggle svelte-uki0cf"),k(n,"slot","toggle")},m(e,t){m(e,n,t)},p:e,d(e){e&&g(n)}}}function nt(e){let t,n=se,o=[];for(let t=0;t<n.length;t+=1)o[t]=rt(Ke(e,n,t));return{c(){for(let e=0;e<o.length;e+=1)o[e].c();t=$()},m(e,n){for(let t=0;t<o.length;t+=1)o[t].m(e,n);m(e,t,n)},p(e,r){if(4&r){let i;for(n=se,i=0;i<n.length;i+=1){const s=Ke(e,n,i);o[i]?o[i].p(s,r):(o[i]=rt(s),o[i].c(),o[i].m(t.parentNode,t))}for(;i<o.length;i+=1)o[i].d(1);o.length=n.length}},d(e){x(o,e),e&&g(t)}}}function ot(e){let t,n=ce,o=[];for(let t=0;t<n.length;t+=1)o[t]=it(Je(e,n,t));return{c(){for(let e=0;e<o.length;e+=1)o[e].c();t=$()},m(e,n){for(let t=0;t<o.length;t+=1)o[t].m(e,n);m(e,t,n)},p(e,r){if(8&r){let i;for(n=ce,i=0;i<n.length;i+=1){const s=Je(e,n,i);o[i]?o[i].p(s,r):(o[i]=it(s),o[i].c(),o[i].m(t.parentNode,t))}for(;i<o.length;i+=1)o[i].d(1);o.length=n.length}},d(e){x(o,e),e&&g(t)}}}function rt(e){let t,n,o,r,i,s,a=e[9]+1+"";return{c(){t=b("div"),n=y("Effect "),o=y(a),r=w(),k(t,"class","action svelte-uki0cf")},m(a,c){m(a,t,c),h(t,n),h(t,o),h(t,r),i||(s=S(t,"click",e[2](e[7])),i=!0)},p(t,n){e=t},d(e){e&&g(t),i=!1,s()}}}function it(e){let t,n,o,r,i,s,a=e[9]+1+"";return{c(){t=b("div"),n=y("Scene "),o=y(a),r=w(),k(t,"class","action svelte-uki0cf")},m(a,c){m(a,t,c),h(t,n),h(t,o),h(t,r),i||(s=S(t,"click",e[3](e[7])),i=!0)},p(t,n){e=t},d(e){e&&g(t),i=!1,s()}}}function st(e){let t;function n(e,t){return"scene"===e[0]?ot:"effect"===e[0]?nt:void 0}let o=n(e),r=o&&o(e);return{c(){r&&r.c(),t=$()},m(e,n){r&&r.m(e,n),m(e,t,n)},p(e,i){o===(o=n(e))&&r?r.p(e,i):(r&&r.d(1),r=o&&o(e),r&&(r.c(),r.m(t.parentNode,t)))},d(e){r&&r.d(e),e&&g(t)}}}function at(e){let t,n,o,r,i,s,a;o=new Xe({});let c=e[1],l=[];for(let t=0;t<c.length;t+=1)l[t]=Qe(Ze(e,c,t));let f="settings"!==e[0]&&et(e);return{c(){t=b("div"),n=b("div"),Z(o.$$.fragment),r=w();for(let e=0;e<l.length;e+=1)l[e].c();i=w(),s=b("div"),f&&f.c(),k(n,"class","svelte-uki0cf"),k(s,"class","svelte-uki0cf"),k(t,"class","toolbar svelte-uki0cf")},m(e,c){m(e,t,c),h(t,n),Q(o,n,null),h(n,r);for(let e=0;e<l.length;e+=1)l[e].m(n,null);h(t,i),h(t,s),f&&f.m(s,null),a=!0},p(e,[t]){if(19&t){let o;for(c=e[1],o=0;o<c.length;o+=1){const r=Ze(e,c,o);l[o]?l[o].p(r,t):(l[o]=Qe(r),l[o].c(),l[o].m(n,null))}for(;o<l.length;o+=1)l[o].d(1);l.length=c.length}"settings"!==e[0]?f?(f.p(e,t),1&t&&X(f,1)):(f=et(e),f.c(),X(f,1),f.m(s,null)):f&&(Y(),K(f,1,1,(()=>{f=null})),H())},i(e){a||(X(o.$$.fragment,e),X(f),a=!0)},o(e){K(o.$$.fragment,e),K(f),a=!1},d(e){e&&g(t),ee(o),x(l,e),f&&f.d()}}}function ct(e,t,n){let o;c(e,ue,(e=>n(0,o=e)));return[o,[{id:"scene",name:"Scene"},{id:"effect",name:"Effect"},{id:"settings",name:"Settings"}],e=>()=>{ae.editor=null,ae.source.set(e)},e=>()=>{le.editor=null,le.source.set(e),fe.input.reset()},e=>()=>{v(ue,o=e,o)}]}class lt extends ne{constructor(e){super(),te(this,e,ct,at,i,{})}}var ft=1e-6,ut="undefined"!=typeof Float32Array?Float32Array:Array,dt=Math.PI/180;function pt(e){return e*dt}function vt(){var e=new ut(16);return ut!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var ht=function(e,t,n,o,r){var i,s=1/Math.tan(t/2);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(i=1/(o-r),e[10]=(r+o)*i,e[14]=2*r*o*i):(e[10]=-1,e[14]=-2*o),e};function mt(){var e=new ut(3);return ut!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function gt(e,t,n){var o=new ut(3);return o[0]=e,o[1]=t,o[2]=n,o}function xt(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function bt(e,t,n,o){return e[0]=t,e[1]=n,e[2]=o,e}function yt(e,t,n,o){return e[0]=t[0]+n[0]*o,e[1]=t[1]+n[1]*o,e[2]=t[2]+n[2]*o,e}function wt(e,t){var n=t[0],o=t[1],r=t[2],i=n*n+o*o+r*r;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}function $t(e){return e[0]=0,e[1]=0,e[2]=0,e}var St=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function kt(){var e=new ut(2);return ut!=Float32Array&&(e[0]=0,e[1]=0),e}function Mt(e,t){var n=new ut(2);return n[0]=e,n[1]=t,n}function Ft(e,t){return e[0]=t[0],e[1]=t[1],e}function Lt(e,t,n){return e[0]=t,e[1]=n,e}mt(),function(){var e=kt()}();const Dt=gt(0,1,0);class zt{constructor({device:e,aspect:t=1,fov:n=75,near:o=.1,far:r=1e4}){this.device=e,this.data=new Float32Array(26),this.buffer=e.createBuffer({size:this.data.byteLength+Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=t,this.fov=n,this.near=o,this.far=r,this.inverseMatrix=this.data.subarray(0,16),this.position=this.data.subarray(16,19),this.direction=this.data.subarray(20,23),this.cone=this.data.subarray(23,24),this.data[24]=o,this.data[25]=r,this.projectionMatrix=vt(),this.viewMatrix=vt(),this.target=mt()}setSize(e,t){const{fov:n}=this;this.aspect=e/t,this.cone[0]=2*Math.tan(pt(n)/2)/t,this.updateProjection()}updateProjection(){const{projectionMatrix:e,aspect:t,fov:n,near:o,far:r}=this;ht(e,pt(n),t,o,r),this.updateBuffer()}updateView(){const{viewMatrix:e,direction:t,position:n,target:o}=this;var r,i,s,a,c,l,f,u,d,p,v,h,m,g,x,b,y,w,$,S,k,M,F;wt(t,St(t,o,n)),r=e,s=o,a=Dt,x=(i=n)[0],b=i[1],y=i[2],w=a[0],$=a[1],S=a[2],k=s[0],M=s[1],F=s[2],Math.abs(x-k)<ft&&Math.abs(b-M)<ft&&Math.abs(y-F)<ft?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(r):(v=x-k,h=b-M,m=y-F,c=$*(m*=g=1/Math.hypot(v,h,m))-S*(h*=g),l=S*(v*=g)-w*m,f=w*h-$*v,(g=Math.hypot(c,l,f))?(c*=g=1/g,l*=g,f*=g):(c=0,l=0,f=0),u=h*f-m*l,d=m*c-v*f,p=v*l-h*c,(g=Math.hypot(u,d,p))?(u*=g=1/g,d*=g,p*=g):(u=0,d=0,p=0),r[0]=c,r[1]=u,r[2]=v,r[3]=0,r[4]=l,r[5]=d,r[6]=h,r[7]=0,r[8]=f,r[9]=p,r[10]=m,r[11]=0,r[12]=-(c*x+l*b+f*y),r[13]=-(u*x+d*b+p*y),r[14]=-(v*x+h*b+m*y),r[15]=1),this.updateBuffer()}updateBuffer(){const{buffer:e,data:t,device:n,projectionMatrix:o,viewMatrix:r,inverseMatrix:i}=this;var s,a,c,l,f,u,d,p,v,h,m,g,x,b,y,w,$,S,k,M,F,L,D;!function(e,t){var n=t[0],o=t[1],r=t[2],i=t[3],s=t[4],a=t[5],c=t[6],l=t[7],f=t[8],u=t[9],d=t[10],p=t[11],v=t[12],h=t[13],m=t[14],g=t[15],x=n*a-o*s,b=n*c-r*s,y=n*l-i*s,w=o*c-r*a,$=o*l-i*a,S=r*l-i*c,k=f*h-u*v,M=f*m-d*v,F=f*g-p*v,L=u*m-d*h,D=u*g-p*h,z=d*g-p*m,P=x*z-b*D+y*L+w*F-$*M+S*k;P&&(P=1/P,e[0]=(a*z-c*D+l*L)*P,e[1]=(r*D-o*z-i*L)*P,e[2]=(h*S-m*$+g*w)*P,e[3]=(d*$-u*S-p*w)*P,e[4]=(c*F-s*z-l*M)*P,e[5]=(n*z-r*F+i*M)*P,e[6]=(m*y-v*S-g*b)*P,e[7]=(f*S-d*y+p*b)*P,e[8]=(s*D-a*F+l*k)*P,e[9]=(o*F-n*D-i*k)*P,e[10]=(v*$-h*y+g*x)*P,e[11]=(u*y-f*$-p*x)*P,e[12]=(a*M-s*L-c*k)*P,e[13]=(n*L-o*M+r*k)*P,e[14]=(h*b-v*w-m*x)*P,e[15]=(f*w-u*b+d*x)*P)}(i,(s=i,a=o,c=r,l=a[0],f=a[1],u=a[2],d=a[3],p=a[4],v=a[5],h=a[6],m=a[7],g=a[8],x=a[9],b=a[10],y=a[11],w=a[12],$=a[13],S=a[14],k=a[15],M=c[0],F=c[1],L=c[2],D=c[3],s[0]=M*l+F*p+L*g+D*w,s[1]=M*f+F*v+L*x+D*$,s[2]=M*u+F*h+L*b+D*S,s[3]=M*d+F*m+L*y+D*k,M=c[4],F=c[5],L=c[6],D=c[7],s[4]=M*l+F*p+L*g+D*w,s[5]=M*f+F*v+L*x+D*$,s[6]=M*u+F*h+L*b+D*S,s[7]=M*d+F*m+L*y+D*k,M=c[8],F=c[9],L=c[10],D=c[11],s[8]=M*l+F*p+L*g+D*w,s[9]=M*f+F*v+L*x+D*$,s[10]=M*u+F*h+L*b+D*S,s[11]=M*d+F*m+L*y+D*k,M=c[12],F=c[13],L=c[14],D=c[15],s[12]=M*l+F*p+L*g+D*w,s[13]=M*f+F*v+L*x+D*$,s[14]=M*u+F*h+L*b+D*S,s[15]=M*d+F*m+L*y+D*k,s)),n.queue.writeBuffer(e,0,t)}}zt.WGSL="\nstruct Camera {\n  inverseMatrix : mat4x4<f32>,\n  position : vec3<f32>,\n  direction : vec3<f32>,\n  cone : f32,\n  near : f32,\n  far : f32,\n}\n";const Pt=mt(),Et=kt(),_t=mt(),qt=mt(),Tt=mt(),Ct=gt(0,1,0);class Bt{constructor({camera:e,target:t}){var n,o;this.camera=e,this.target=t,this.isFullscreen=!1,this.isLocked=!1,this.gamepad=null,this.keyboard={buttons:{run:!1},movement:mt()},this.pointer={buttons:{primary:!1},movement:kt(),position:kt()},this.buttons={primary:!1},this.forward=mt(),this.look={state:Mt(.5*Math.PI,Math.PI),target:Mt(.5*Math.PI,Math.PI)},this.position={state:e.position,target:(n=e.position,o=new ut(3),o[0]=n[0],o[1]=n[1],o[2]=n[2],o)},this.speed={state:4,target:4},this.updateBounds(),t.addEventListener("contextmenu",this.onContextMenu.bind(this),!1),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnected.bind(this),!1),window.addEventListener("gamepadconnected",this.onGamepadConnected.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1),t.addEventListener("mousedown",this.onMouseDown.bind(this),!1),window.addEventListener("mousemove",this.onMouseMove.bind(this),!1),window.addEventListener("mouseup",this.onMouseUp.bind(this),!1),window.addEventListener("wheel",this.onMouseWheel.bind(this),{passive:!1}),document.addEventListener("fullscreenchange",this.onFullscreen.bind(this),!1),document.addEventListener("pointerlockchange",this.onPointerLock.bind(this),!1)}enterFullscreen(){const{isFullscreen:e,target:t}=this;e||t.requestFullscreen()}exitFullscreen(){const{isFullscreen:e}=this;e&&document.exitFullscreen()}lock(){const{isLocked:e,target:t}=this;e||t.requestPointerLock()}unlock(){const{isLocked:e}=this;e&&document.exitPointerLock()}onContextMenu(e){e.preventDefault()}onGamepadDisconnected({gamepad:{index:e}}){const{gamepad:t}=this;t===e&&(this.gamepad=null)}onGamepadConnected({gamepad:{index:e}}){this.gamepad=e}onKeyDown({key:e,repeat:t}){const{isLocked:n,keyboard:o}=this;if(n&&!t)switch(e.toLowerCase()){case"w":o.movement[2]=1;break;case"s":o.movement[2]=-1;break;case"a":o.movement[0]=-1;break;case"d":o.movement[0]=1;break;case"q":o.movement[1]=-1;break;case"e":o.movement[1]=1;break;case"shift":o.buttons.run=!0;break;case"r":this.reset()}}onKeyUp({key:e}){const{isLocked:t,keyboard:n}=this;if(t)switch(e.toLowerCase()){case"w":n.movement[2]>0&&(n.movement[2]=0);break;case"s":n.movement[2]<0&&(n.movement[2]=0);break;case"a":n.movement[0]<0&&(n.movement[0]=0);break;case"d":n.movement[0]>0&&(n.movement[0]=0);break;case"q":n.movement[1]<0&&(n.movement[1]=0);break;case"e":n.movement[1]>0&&(n.movement[1]=0);break;case"shift":n.buttons.run=!1}}onMouseDown({button:e}){const{isFullscreen:t,isLocked:n,pointer:o}=this;if(!n)return this.lock(),void(t||this.enterFullscreen());o.buttons.primary=0===e||2===e}onMouseMove({clientX:e,clientY:t,movementX:n,movementY:o}){const{sensitivity:r}=Bt,{bounds:i,isLocked:s,pointer:{movement:a,position:c}}=this;s&&(a[0]-=n*r.pointer,a[1]+=o*r.pointer,Lt(c,(e-i.x)/i.width*2-1,-(t-i.y)/i.height*2+1))}onMouseUp({button:e}){const{isLocked:t,pointer:n}=this;!t||0!==e&&2!==e||(n.buttons.primary=!1)}onMouseWheel(e){const{sensitivity:t,minSpeed:n,speedRange:o}=Bt,{isLocked:r,speed:i}=this;if(e.ctrlKey&&e.preventDefault(),!r)return;const s=Math.min(Math.max((Math.log(i.target)-n)/o-e.deltaY*t.wheel,0),1);i.target=Math.exp(n+s*o)}onFullscreen(){this.isFullscreen=!!document.fullscreenElement}onPointerLock(){const{buttons:e,keyboard:t,pointer:n}=this;this.isLocked=!!document.pointerLockElement,this.isLocked||(e.primary=!1,bt(t.movement,0,0,0),t.buttons.run=!1,n.buttons.primary=!1)}update(e){const{minPhi:t,maxPhi:n,sensitivity:o}=Bt,{isLocked:r,buttons:i,camera:s,forward:a,gamepad:c,keyboard:l,pointer:f,look:u,position:d,speed:p}=this;let v=!1;if(r){if(v=l.buttons.run,i.primary=f.buttons.primary,xt(_t,l.movement),Ft(Et,f.movement),null!==c){const{axes:e,buttons:t}=navigator.getGamepads()[c];(t[6]&&t[6].pressed||t[7]&&t[7].pressed)&&(i.primary=!0),Math.max(Math.abs(e[2]),Math.abs(e[3]))>.1&&Lt(Et,-e[2]*o.gamepad,-e[3]*o.gamepad),Math.max(Math.abs(e[0]),Math.abs(e[1]))>.1&&bt(_t,e[0],0,-e[1]),t[4]&&t[4].pressed?_t[1]=-1:t[5]&&t[5].pressed&&(_t[1]=1),t[10]&&t[10].pressed&&(v=!0)}u.target[0]=Math.min(Math.max(u.target[0]+Et[1],t),n),u.target[1]+=Et[0]}Lt(f.movement,0,0);{const t=1-Math.exp(-20*e);h=u.state,m=u.state,g=u.target,x=t,b=m[0],y=m[1],h[0]=b+x*(g[0]-b),h[1]=y+x*(g[1]-y),p.state=p.state*(1-t)+p.target*t}var h,m,g,x,b,y;if(bt(a,Math.sin(u.state[0])*Math.sin(u.state[1]),Math.cos(u.state[0]),Math.sin(u.state[0])*Math.cos(u.state[1])),0!==_t[0]||0!==_t[1]||0!==_t[2]){xt(qt,a),wt(Tt,function(e,t,n){var o=t[0],r=t[1],i=t[2],s=n[0],a=n[1],c=n[2];return e[0]=r*c-i*a,e[1]=i*s-o*c,e[2]=o*a-r*s,e}(Tt,qt,Ct)),$t(Pt),yt(Pt,Pt,Tt,_t[0]),yt(Pt,Pt,Ct,_t[1]),yt(Pt,Pt,qt,_t[2]),$t(_t);const t=function(e){var t=e[0],n=e[1],o=e[2];return Math.hypot(t,n,o)}(Pt);t>1&&function(e,t,n){e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n}(Pt,Pt,1/t),yt(d.target,d.target,Pt,e*p.state*(v?2:1))}{const t=1-Math.exp(-10*e);!function(e,t,n,o){var r=t[0],i=t[1],s=t[2];e[0]=r+o*(n[0]-r),e[1]=i+o*(n[1]-i),e[2]=s+o*(n[2]-s)}(d.state,d.state,d.target,t),function(e,t,n){e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2]}(s.target,s.position,a),s.updateView()}}updateBounds(){const{target:e}=this,t=e.getBoundingClientRect();this.bounds={width:Math.max(t.width,1),height:Math.max(t.height,1),x:t.x,y:t.y}}reset(){const{look:e,position:t}=this;$t(t.target),xt(t.state,t.target),Lt(e.target,.5*Math.PI,Math.PI),Ft(e.state,e.target)}}Bt.sensitivity={gamepad:.03,pointer:.003,wheel:3e-4},Bt.minPhi=.01,Bt.maxPhi=Math.PI-.01,Bt.minSpeed=Math.log(2),Bt.maxSpeed=Math.log(64),Bt.speedRange=Bt.maxSpeed-Bt.minSpeed;var Rt="struct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) ray : vec3<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> time : f32;\n\nconst epsilon : f32 = 0.01;\n\nfn getNormal(pos : vec3<f32>, distance : f32) -> vec3<f32> {\n  const o : vec2<f32> = vec2<f32>(epsilon, 0);\n  return normalize(\n    distance - vec3<f32>(\n      getScene(pos - o.xyy).distance,\n      getScene(pos - o.yxy).distance,\n      getScene(pos - o.yyx).distance\n    )\n  );\n}\n\n@vertex\nfn vertex(@builtin(vertex_index) index : u32) -> VertexOutput {\n  // Hack to prevent BindGroup errors\n  // when user code doesn't use all of the uniforms\n  let t : f32 = time;\n\n  const quad = array<vec2<f32>, 6>(\n    vec2<f32>(-1, -1), vec2<f32>(1, -1), vec2<f32>(-1, 1),\n    vec2<f32>(-1, 1), vec2<f32>(1, -1), vec2<f32>(1, 1)\n  );\n  var out : VertexOutput;\n  out.position = vec4<f32>(quad[index], 0, 1);\n  let r : vec4<f32> = camera.inverseMatrix * vec4<f32>(quad[index], 0.5, 1);\n  out.ray = normalize((r.xyz / r.w) - camera.position);\n  return out;\n}\n\n@fragment\nfn conetracing(@location(0) ray : vec3<f32>) -> FragmentOutput {\n  var out : FragmentOutput;\n  var coverage : f32 = 1;\n  var depth : f32 = camera.near;\n  for (var i : u32 = 0; i < maxIterations && depth < camera.far; i++) {\n    let pos : vec3<f32> = camera.position + ray * depth;\n    let step : SDF = getScene(pos);\n    let cone : f32 = camera.cone * depth;\n    if (step.distance < cone) {\n      let alpha : f32 = smoothstep(cone, -cone, step.distance);\n      let normal : vec3<f32> = getNormal(pos, step.distance);\n      out.color += vec4<f32>(step.color * alpha * coverage, 0);\n      out.data += vec4<f32>(normal, depth) * alpha * coverage;\n      out.position += vec4<f32>(pos * alpha * coverage, 0);\n      coverage *= 1 - alpha;\n      if (coverage <= epsilon * 0.1) {\n        break;\n      }\n    }\n    depth += max(step.distance, epsilon);\n  }\n  if (coverage < 1) {\n    out.color = vec4<f32>(out.color.xyz, 1 - coverage);\n    out.data = vec4<f32>(normalize(out.data.xyz), out.data.w);\n    return out;\n  }\n  discard;\n}\n\n@fragment\nfn raymarching(@location(0) ray : vec3<f32>) -> FragmentOutput {\n  var out : FragmentOutput;\n  var depth : f32 = camera.near;\n  for (var i : u32 = 0; i < maxIterations && depth < camera.far; i++) {\n    let pos : vec3<f32> = camera.position + ray * depth;\n    let step : SDF = getScene(pos);\n    if (step.distance < epsilon) {\n      let normal : vec3<f32> = getNormal(pos, step.distance);\n      out.color = vec4<f32>(step.color, 1);\n      out.data = vec4<f32>(normal, depth);\n      out.position = vec4<f32>(pos, 1);\n      return out;\n    }\n    depth += max(step.distance, epsilon);\n  }\n  discard;\n}\n",Ut="fn hsl2Rgb(hsl : vec3<f32>) -> vec3<f32> {\n  let h : f32 = clamp(hsl.x, 0, 1);\n  let s : f32 = clamp(hsl.y, 0, 1);\n  let l : f32 = clamp(hsl.z, 0, 1);\n  if (s == 0) {\n    return vec3<f32>(l, l, l);\n  }\n  var q : f32;\n  if (l < 0.5) {\n    q = l * (1 + s);\n  } else {\n    q = l + s - l * s;\n  }\n  let p = 2 * l - q;\n  return vec3<f32>(\n    hue2Rgb(p, q, h + 1 / 3.0),\n    hue2Rgb(p, q, h),\n    hue2Rgb(p, q, h - 1 / 3.0)\n  );\n}\n\nfn hue2Rgb(p : f32, q : f32, tt : f32) -> f32 {\n  var t : f32 = tt;\n  if (t < 0) { t += 1; }\n  if (t > 1) { t -= 1; }\n  if (t < 1 / 6.0) { return p + (q - p) * 6 * t; }\n  if (t < 1 / 2.0) { return q; }\n  if (t < 2 / 3.0) { return p + (q - p) * (2 / 3.0 - t) * 6; }\n  return p;\n}\n",It="fn permute4(x : vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r : vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn SimplexNoise(v : vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n",At="const PI : f32 = 3.141592653589793;\n\nfn rotateX(radians : f32) -> mat3x3<f32> {\n  var c : f32 = cos(radians);\n  var s : f32 = sin(radians);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(radians : f32) -> mat3x3<f32> {\n  var c : f32 = cos(radians);\n  var s : f32 = sin(radians);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn rotateZ(radians : f32) -> mat3x3<f32> {\n  var c : f32 = cos(radians);\n  var s : f32 = sin(radians);\n  return mat3x3<f32>(\n    c, s, 0,\n    -s, c, 0,\n    0, 0, 1,\n  );\n}\n\nfn spherical(phi : f32, theta : f32, radius : f32) -> vec3<f32> {\n  let sinPhiRadius = sin(phi) * radius;\n  return vec3<f32>(\n    sinPhiRadius * sin(theta),\n    cos(phi) * radius,\n    sinPhiRadius * cos(theta)\n  );\n}\n",Nt="struct SDF {\n  color : vec3<f32>,\n  distance : f32,\n}\n\nfn opUnion(a : SDF, b : SDF) -> SDF {\n  if (a.distance < b.distance) {\n    return a;\n  }\n  return b;\n}\n\nfn opSubstraction(a : SDF, b : SDF) -> SDF {\n  if (a.distance > -b.distance) {\n    return a;\n  }\n  return SDF(b.color, -b.distance);\n}\n\nfn opSmoothUnion(a : SDF, b : SDF, k : f32) -> SDF {\n  let h : f32 = clamp(0.5 + 0.5 * (b.distance - a.distance) / k, 0, 1);\n  return SDF(\n    mix(b.color, a.color, h),\n    mix(b.distance, a.distance, h) - k*h*(1-h)\n  );\n}\n\nfn opSmoothSubstraction(a : SDF, b : SDF, k : f32) -> SDF {\n  let h : f32 = clamp(0.5 - 0.5 * (a.distance + b.distance) / k, 0, 1);\n  return SDF(\n    mix(a.color, b.color, h),\n    mix(a.distance, -b.distance, h) + k*h*(1-h)\n  );\n}\n\nfn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  let q : vec3<f32> = abs(p) - r;\n  return length(max(q, vec3<f32>(0))) + min(max(q.x, max(q.y, q.z)), 0);\n}\n\nfn sdCapsule(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  let q : vec3<f32> = vec3<f32>(p.x, p.y - clamp(p.y, -r.y + r.x, r.y - r.x), p.z);\n  return length(q) - r.x;\n}\n\nfn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  let k0 : f32 = length(p / r);\n  let k1 : f32 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfn sdPlane(p : vec3<f32>, n : vec3<f32>, h : f32) -> f32 {\n  return dot(p,n) + h;\n}\n\nfn sdSphere(p : vec3<f32>, r : f32) -> f32 {\n  return length(p) - r;\n}\n\nfn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  let q : vec2<f32> = vec2<f32>(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n";class Ot{constructor(e){this.renderer=e}render(e){const{bindings:t,pipeline:n}=this;e.setPipeline(n),e.setBindGroup(0,t),e.draw(6)}setMaxIterations(e){this.maxIterations=e,this.updatePipeline()}setMode(e){this.mode=e,this.updatePipeline()}setScene(e){this.scene=e,this.updatePipeline()}updatePipeline(){const{renderer:{camera:e,device:t,time:n},maxIterations:o,mode:r,scene:i}=this;o&&r&&i&&(this.code=[`const maxIterations : u32 = ${o};`,e.constructor.WGSL,Rt,Ut,It,At,Nt,"// __SOURCE__",i].join("\n"),this.module=t.createShaderModule({code:this.code}),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{entryPoint:"vertex",module:this.module},fragment:{entryPoint:r,module:this.module,targets:[{format:"rgba32float"},{format:"rgba32float"},{format:"rgba32float"}]},primitive:{topology:"triangle-list"}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:{buffer:n}}]}))}}var jt="@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> time : f32;\n@group(1) @binding(0) var colorTexture : texture_2d<f32>;\n@group(1) @binding(1) var dataTexture : texture_2d<f32>;\n@group(1) @binding(2) var positionTexture : texture_2d<f32>;\n\nfn linearTosRGB(linear : vec3<f32>) -> vec3<f32> {\n  if (all(linear <= vec3<f32>(0.0031308))) {\n    return linear * 12.92;\n  }\n  return (pow(abs(linear), vec3<f32>(1.0/2.4)) * 1.055) - vec3<f32>(0.055);\n}\n\n@vertex\nfn vertex(@builtin(vertex_index) index : u32) -> @builtin(position) vec4<f32> {\n  // Hack to prevent BindGroup errors\n  // when user code doesn't use all of the uniforms\n  let t : f32 = time;\n\n  const quad = array<vec2<f32>, 6>(\n    vec2<f32>(-1, -1), vec2<f32>(1, -1), vec2<f32>(-1, 1),\n    vec2<f32>(-1, 1), vec2<f32>(1, -1), vec2<f32>(1, 1)\n  );\n  return vec4<f32>(quad[index], 0, 1);\n}\n\n@fragment\nfn fragment(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  return vec4<f32>(linearTosRGB(getEffect(vec2<i32>(floor(uv.xy)))), 1);\n}\n",Gt="struct Light {\n  position : vec3<f32>,\n  diffuse : vec3<f32>,\n  specular : vec3<f32>,\n}\n\nfn getAttenuation(dist : f32, constant : f32, linear : f32, quadratic : f32) -> f32 {\n  return 1.0 / (constant + linear * dist + quadratic * (dist * dist));\n}\n\nfn getDirectLight(light : Light, normal : vec3<f32>, position : vec3<f32>, shininess : f32) -> vec3<f32> {\n  let lightDir = normalize(light.position - position);\n  let viewDir : vec3<f32> = normalize(camera.position - position);\n  let halfwayDir : vec3<f32> = normalize(lightDir + viewDir);\n\n  let diffuse : vec3<f32> = max(dot(lightDir, normal), 0) * light.diffuse;\n  let specular : vec3<f32> = pow(max(dot(normal, halfwayDir), 0), shininess) * light.specular;\n\n  return diffuse + specular;\n}\n";class Vt{constructor({device:e,camera:t,format:n,time:o}){this.device=e,this.camera=t,this.format=n,this.time=o,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]}}render(e,t){const{bindings:n,descriptor:o,pipeline:r,uniforms:i}=this;o.colorAttachments[0].view=t;const s=e.beginRenderPass(o);s.setPipeline(r),s.setBindGroup(0,i),s.setBindGroup(1,n),s.draw(6),s.end()}bindTextures(){const{device:e,pipeline:t,textures:n}=this;t&&n&&(this.bindings=e.createBindGroup({layout:t.getBindGroupLayout(1),entries:[{binding:0,resource:n.color},{binding:1,resource:n.data},{binding:2,resource:n.position}]}))}setEffect(e){const{device:t,camera:n,format:o,time:r}=this;this.code=[n.constructor.WGSL,jt,Gt,At,"// __SOURCE__",e].join("\n"),this.module=t.createShaderModule({code:this.code}),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{entryPoint:"vertex",module:this.module},fragment:{entryPoint:"fragment",module:this.module,targets:[{format:o}]},primitive:{topology:"triangle-list"}}),this.uniforms=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:r}}]}),this.bindTextures()}setTextures({color:e,data:t,position:n}){this.textures={color:e,data:t,position:n},this.bindTextures()}}class Wt{constructor({adapter:e,camera:t,device:n}){const o=navigator.gpu.getPreferredCanvasFormat(e);this.camera=t,this.device=n,this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:n,format:o}),this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:t.far},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}]},this.time=n.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.postprocessing=new Vt({device:n,camera:t,format:o,time:this.time}),this.scene=[],this.textures=new Map}render(e){const{context:t,descriptor:n,postprocessing:o,scene:r}=this,i=e.beginRenderPass(n);r.forEach((e=>e.render(i))),i.end(),o.render(e,t.getCurrentTexture().createView())}setSize(e,t,n=window.devicePixelRatio||1){const{camera:o,canvas:r,descriptor:i,postprocessing:s}=this,a=[Math.floor(e*n),Math.floor(t*n)];r.width=a[0],r.height=a[1],r.style.width=`${e}px`,r.style.height=`${t}px`,o.setSize(a[0],a[1]),this.updateTexture(i.colorAttachments[0],"rgba32float","color",a),this.updateTexture(i.colorAttachments[1],"rgba32float","data",a),this.updateTexture(i.colorAttachments[2],"rgba32float","position",a),s.setTextures({color:i.colorAttachments[0].view,data:i.colorAttachments[1].view,position:i.colorAttachments[2].view})}updateTexture(e,t,n,o){const{device:r,textures:i}=this,s=i.get(n);s&&s.destroy();const a=r.createTexture({format:t,size:o,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});e.view=a.createView(),i.set(n,a)}}function Yt(t){let n;return{c(){n=b("div"),k(n,"class","viewport svelte-vo8in0")},m(e,o){m(e,n,o),t[1](n)},p:e,i:e,o:e,d(e){e&&g(n),t[1](null)}}}function Ht(e,t,n){let o;return E((()=>{const{adapter:e,device:t}=fe.gpu,n=new zt({device:t}),r=new Bt({camera:n,target:o}),i=new Wt({adapter:e,camera:n,device:t});o.appendChild(i.canvas),i.setSize(window.innerWidth,window.innerHeight),i.setSize(r.bounds.width,r.bounds.height),window.addEventListener("resize",(()=>{r.updateBounds(),i.setSize(r.bounds.width,r.bounds.height)}),!1);const s=new Ot(i);i.scene.push(s);const a=new Float32Array([performance.now()/1e3]);document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(a[0]=performance.now()/1e3)}),!1);let c=!1;const l=()=>{requestAnimationFrame(l);const e=performance.now()/1e3,n=Math.min(e-a[0],1);if(a[0]=e,c)return;r.update(n),t.queue.writeBuffer(i.time,0,a);const o=t.createCommandEncoder();i.render(o),t.queue.submit([o.finish()])},f=({code:e,module:t},n)=>{c=!1;const o=e.split("\n"),r=o.indexOf("// __SOURCE__")+1;t.compilationInfo().then((({messages:e})=>n.set(e.map((({length:e,lineNum:t,linePos:n,message:i,type:s})=>(c=!0,{line:o[t-1],lineNum:t-r,linePos:n,length:e,message:i,pointer:Array.from({length:n-1+e},((e,t)=>t>=n-1?"^":" ")).join(""),type:s}))))))};fe.input=r;const u=[fe.iterations.subscribe((e=>s.setMaxIterations(e))),fe.mode.subscribe((e=>s.setMode(e))),ae.source.subscribe((e=>{i.postprocessing.setEffect(e),f(i.postprocessing,ae.errors)})),le.source.subscribe((e=>{s.setScene(e),f(s,le.errors)}))];return requestAnimationFrame(l),()=>{u.forEach((e=>e())),fe.input=null}})),[o,function(e){q[e?"unshift":"push"]((()=>{o=e,n(0,o)}))}]}class Xt extends ne{constructor(e){super(),te(this,e,Ht,Yt,i,{})}}const{window:Kt}=J;function Jt(e){let t,n;return t=new Re({}),{c(){Z(t.$$.fragment)},m(e,o){Q(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){K(t.$$.fragment,e),n=!1},d(e){ee(t,e)}}}function Zt(e){let t,n;return t=new ye({}),{c(){Z(t.$$.fragment)},m(e,o){Q(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){K(t.$$.fragment,e),n=!1},d(e){ee(t,e)}}}function Qt(e){let t,n;return t=new xe({}),{c(){Z(t.$$.fragment)},m(e,o){Q(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){K(t.$$.fragment,e),n=!1},d(e){ee(t,e)}}}function en(e){let t,n,i,s,a,c,l,f,u,d,p,v,x;i=new lt({});const y=[Qt,Zt,Jt],$=[];function M(e,t){return"effect"===e[1]?0:"scene"===e[1]?1:"settings"===e[1]?2:-1}return~(a=M(e))&&(c=$[a]=y[a](e)),d=new Xt({}),{c(){t=b("div"),n=b("div"),Z(i.$$.fragment),s=w(),c&&c.c(),l=w(),f=b("div"),u=w(),Z(d.$$.fragment),k(n,"class","ui svelte-efpout"),F(n,"width",e[0].state+"px"),k(f,"class","divider svelte-efpout"),k(t,"class","app svelte-efpout")},m(o,c){m(o,t,c),h(t,n),Q(i,n,null),h(n,s),~a&&$[a].m(n,null),h(t,l),h(t,f),h(t,u),Q(d,t,null),p=!0,v||(x=[S(Kt,"mousemove",(function(){r(e[0].enabled&&e[3])&&(e[0].enabled&&e[3]).apply(this,arguments)})),S(Kt,"mouseup",(function(){r(e[0].enabled&&e[4])&&(e[0].enabled&&e[4]).apply(this,arguments)})),S(f,"mousedown",e[2])],v=!0)},p(t,[o]){let r=a;a=M(e=t),a!==r&&(c&&(Y(),K($[r],1,1,(()=>{$[r]=null})),H()),~a?(c=$[a],c||(c=$[a]=y[a](e),c.c()),X(c,1),c.m(n,null)):c=null),(!p||1&o)&&F(n,"width",e[0].state+"px")},i(e){p||(X(i.$$.fragment,e),X(c),X(d.$$.fragment,e),p=!0)},o(e){K(i.$$.fragment,e),K(c),K(d.$$.fragment,e),p=!1},d(e){e&&g(t),ee(i),~a&&$[a].d(),ee(d),v=!1,o(x)}}}function tn(e,t,n){let o;c(e,ue,(e=>n(1,o=e)));const r={enabled:!1,initial:0,offset:0,state:512};return[r,o,({clientX:e})=>{n(0,r.enabled=!0,r),n(0,r.initial=r.state,r),n(0,r.offset=e,r)},({clientX:e})=>{n(0,r.state=Math.max(Math.floor(r.initial+e-r.offset),340),r),I().then((()=>window.dispatchEvent(new Event("resize"))))},()=>{n(0,r.enabled=!1,r)}]}class nn extends ne{constructor(e){super(),te(this,e,tn,en,i,{})}}function on(e){let t,n;return t=new nn({}),{c(){Z(t.$$.fragment)},m(e,o){Q(t,e,o),n=!0},i(e){n||(X(t.$$.fragment,e),n=!0)},o(e){K(t.$$.fragment,e),n=!1},d(e){ee(t,e)}}}function rn(t){let n;return{c(){n=b("div"),n.innerHTML='Sorry! You&#39;ll need to try this in a browser with WebGPU support like <a href="https://www.google.com/chrome" rel="noopener noreferrer" target="_blank" class="svelte-1bwkh19">Chrome</a>.',k(n,"class","support svelte-1bwkh19")},m(e,t){m(e,n,t)},i:e,o:e,d(e){e&&g(n)}}}function sn(t){let n;return{c(){n=b("div"),n.textContent="Loading...",k(n,"class","loading svelte-1bwkh19")},m(e,t){m(e,n,t)},i:e,o:e,d(e){e&&g(n)}}}function an(e){let t,n,o,r,i,s,a;const c=[sn,rn,on],l=[];function f(e,t){return e[1]?0:e[0]?1:2}return t=f(e),n=l[t]=c[t](e),{c(){n.c(),o=w(),r=b("div"),r.innerHTML='marcher - <a href="https://github.com/danielesteban/marcher" rel="noopener noreferrer" target="_blank" class="svelte-1bwkh19">view source</a><br/> \n  <a href="https://dani.gatunes.com" rel="noopener noreferrer" target="_blank" class="svelte-1bwkh19">dani@gatunes</a>  2022',i=w(),s=b("a"),s.textContent=" Become a sponsor",k(r,"class","info svelte-1bwkh19"),k(s,"class","ribbon svelte-1bwkh19"),k(s,"href","https://github.com/sponsors/danielesteban"),k(s,"data-ribbon"," Become a sponsor"),k(s,"rel","noopener noreferrer"),k(s,"target","_blank")},m(e,n){l[t].m(e,n),m(e,o,n),m(e,r,n),m(e,i,n),m(e,s,n),a=!0},p(e,[r]){let i=t;t=f(e),t!==i&&(Y(),K(l[i],1,1,(()=>{l[i]=null})),H(),n=l[t],n||(n=l[t]=c[t](e),n.c()),X(n,1),n.m(o.parentNode,o))},i(e){a||(X(n),a=!0)},o(e){K(n),a=!1},d(e){l[t].d(e),e&&g(o),e&&g(r),e&&g(i),e&&g(s)}}}function cn(e,t,n){let o=!1,r=!0;return Promise.all([(async()=>{if(!navigator.gpu)throw new Error("WebGPU support");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU adapter");const t=await e.requestDevice();return{adapter:e,device:t}})(),new Promise((e=>{require.config({paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs"}}),require(["vs/editor/editor.main"],e)}))]).then((([e])=>{fe.gpu=e})).catch((e=>{console.error(e),n(0,o=!0)})).finally((()=>{n(1,r=!1)})),[o,r]}new class extends ne{constructor(e){super(),te(this,e,cn,an,i,{})}}({target:document.body})}();
